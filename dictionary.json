{
  "version": "1.0.3",
  "homePage": "",
  "Intrinsic_help_url": "https://developer.arm.com/architectures/instruction-sets/simd-isas/neon/intrinsics",
  "Category": [
    {
      "cnName": "压缩库",
      "enName": "Compression library",
      "cnDesc": "使用鲲鹏硬件加速模块或鲲鹏指令对业界主流的开源压缩库（zlib、gzip、zstd、snappy等）进行性能优化，优化后压缩库通过鲲鹏社区发布",
      "enDesc": "The Kunpeng hardware acceleration module or Kunpeng instructions are used to optimize the performance of mainstream open-source compression libraries (such as zlib, gzip, zstd, and Snappy). The optimized compression libraries are released in the Kunpeng Community.",
      "id": "1"
    },
    {
      "cnName": "系统库",
      "enName": "System library",
      "cnDesc": "基于鲲鹏微架构特点，使用鲲鹏指令对系统通用的基础库进行性能优化，以及传统平台的指令函数映射到鲲鹏平台的公共模块",
      "enDesc": "Kunpeng instructions are used to optimize the performance of the common basic library of the system based on the Kunpeng micro-architecture features, and the instruction functions of the traditional platform are mapped to the common modules of the Kunpeng platform.",
      "id": "2"
    },
    {
      "cnName": "加解密库",
      "enName": "Encryption and decryption library",
      "cnDesc": "使用鲲鹏硬件加速模块及鲲鹏指令对openssl库进行性能优化，支持硬加速与指令加速的自动协同、应用逻辑无需修改即可使用加解密加速库",
      "enDesc": "The Kunpeng hardware acceleration module and Kunpeng instructions are used to optimize the performance of the OpenSSL library. Automatic collaboration between hardware acceleration and instruction acceleration is supported. The encryption and decryption acceleration library can be used without modifying the application logic.",
      "id": "3"
    },
    {
      "cnName": "媒体库",
      "enName": "Media library",
      "cnDesc": "基于鲲鹏加速指令提供高性能媒体原语库及视频编解码库",
      "enDesc": "High-performance media primitive library and video encoding/decoding library are provided based on Kunpeng acceleration instructions.",
      "id": "4"
    },
    {
      "cnName": "数学库",
      "enName": "Math library",
      "cnDesc": "鲲鹏数学库提供了基于鲲鹏平台优化的高性能数学函数，所有接口由C/C++、汇编语言实现。",
      "enDesc": "The Kunpeng Math Library (KML) provides high-performance mathematical functions optimized based on the Kunpeng platform. All interfaces are implemented by C/C++ and the assembly language.",
      "id": "5"
    }
  ],
  "library": [
    {
      "name": "glibc_patch",
      "category id": "2",
      "cnDesc": "对内存、字符串、锁等接口基于华为鲲鹏920处理器微架构特点进行了加速优化",
      "enDesc": "The memory, string, and lock are optimized and accelerated based on the microarchitecture of Huawei Kunpeng 920 processors.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/glibc.html",
      "code_url": "http://ftp.jaist.ac.jp/pub/GNU/libc"
    },
    {
      "name": "hyperscan",
      "category id": "2",
      "cnDesc": "基于鲲鹏微架构优势，使用鲲鹏指令加速正则表达式的编译、扫描性能",
      "enDesc": "Kunpeng instructions are used to accelerate the compilation and scanning performance of regular expressions based on the advantages of the Kunpeng micro-architecture.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/hyperscan.html",
      "code_url": "https://github.com/kunpengcompute/hyperscan"
    },
    {
      "name": "AVX2Neon",
      "category id": "2",
      "cnDesc": "AVX2Neon是一款接口集合库。当时用Intrinsic类接口的应用程序从传统平台迁移到鲲鹏计算平台时，由于各个平台的Intrinsic函数定义不同，需要逐一对Intrinsic函数重新进行适配开发。针对该问题，我们提供了AVX2Neon模块，将传统平台的Intrinsic接口集合使用鲲鹏指令重新实现，并封装为独立的接口模块(C语言头文件方式)，以减少大量迁移项目重复开发的工作量。用户可以通过将头文件导入应用程序即可继续使用传统平台的Intrinsic函数。",
      "enDesc": "AVX2Neon is an interface collection library. When an application using the Intrinsic interface is ported from a conventional platform to the Kunpeng platform, Intrinsic functions need to be re-adapted and developed one by one due to the different Intrinsic function syntax on the platforms. To address this problem, the AVX2Neon module is provided. The Intrinsic interface collection on the conventional platform is re-implemented by using Kunpeng instructions and encapsulated as an independent interface module (in C language header file mode)to reduce the workload of repeated development of porting projects. Users can continue to use the Intrinsic functions of the conventional platform by importing the header file into the application.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/system",
      "code_url": "https://github.com/kunpengcompute/AvxToNeon"
    },
    {
      "name": "gzip",
      "category id": "1",
      "cnDesc": "基于gzip-1.10，通过数据预取、循环展开、CRC指令替换等方法，来提升其在鲲鹏平台上的压缩和解压缩速率，尤其对文本类型文件的压缩及解压具有更明显的性能优势",
      "enDesc": "Data prefetch, loop unrolling, and CRC instruction replacement are used based on gzip-1.10 to improve the compression and decompression speed on the Kunpeng platform, especially the compression and decompression of text files.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/gzip.html",
      "code_url": "https://github.com/kunpengcompute/gzip"
    },
    {
      "name": "zstd",
      "category id": "1",
      "cnDesc": "基于zstd-1.4.4，通过使用NEON指令、内联汇编、代码结构调整、内存预取、指令流水线排布优化等方法，实现zstd在鲲鹏平台上压缩和解压性能的提升",
      "enDesc": "The zstd compression and decompression performance on the Kunpeng platform is improved by using NEON instructions, inline assembly, and memory prefetch, adjusting code structure, and optimizing instruction pipeline layout based on zstd-1.4.4.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/zstd.html",
      "code_url": "https://github.com/kunpengcompute/zstd"
    },
    {
      "name": "snappy",
      "category id": "1",
      "cnDesc": "基于snappy-1.1.7，使用内联汇编、高宽位指令、优化CPU流水线、内存预取等方法，实现snappy在鲲鹏平台上的压缩和解压速率提升",
      "enDesc": "The Snappy compression and decompression rates on the Kunpeng platform are improved by using inline assembly, high-bit instructions, optimized CPU pipeline, and memory prefetch based on Snappy 1.1.7.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/snappy.html",
      "code_url": "https://github.com/kunpengcompute/snappy"
    },
    {
      "name": "KAEzip",
      "category id": "1",
      "cnDesc": "KAEzip是鲲鹏加速引擎的压缩模块，使用鲲鹏硬加速模块实现deflate算法，结合无损用户态驱动框架，提供高性能gzip/zlib格式压缩接口",
      "enDesc": "KAEzip is the compression module of the Kunpeng acceleration engine. It uses the Kunpeng hardware acceleration module to implement the deflate algorithm and works with the lossless user-mode driver framework to provide an interface for high-performance compression in gzip or zlib format.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/kaezip.html",
      "code_url": "https://github.com/kunpengcompute/KAEzip"
    },
    {
      "name": "KAECrypto",
      "category id": "3",
      "cnDesc": "使用鲲鹏硬加速模块实现RSA/SM3/SM4/DH/MD5/AES算法，结合无损用户态驱动框架，提供高性能对称加解密、非对称加解密算法能力，兼容openssl1.1.1a及其之后版本，支持同步&异步机制",
      "enDesc": "The Kunpeng hardware acceleration module implements the RSA, SM3, SM4, DH, MD5, and AES algorithms, provides high-performance symmetric and asymmetric encryption and decryption based on the lossless user-mode driver framework. It is compatible with OpenSSL 1.1.1a and later versions and supports synchronous and asynchronous mechanisms.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/accelerator.html",
      "code_url": "https://github.com/kunpengcompute/KAE"
    },
    {
      "name": "x265-patch",
      "category id": "4",
      "cnDesc": "针对ffmpeg视频转码场景，对x265的转码底层算子使用鲲鹏向量指令进行加速优化，提高转码性能",
      "enDesc": "The underlying x265 transcoding operators are accelerated and optimized by using the Kunpeng vector instruction to improve the transcoding performance in FFmpeg video transcoding scenarios.",
      "kunpeng_url": "https://www.huaweicloud.com/kunpeng/software/x265-patch.html",
      "code_url": "http://x265.org/blog/"
    },
    {
      "name": "HW265",
      "category id": "4",
      "cnDesc": "HW265视频编码器是符合H.265/HEVC视频编码标准、基于鲲鹏处理器NEON指令加速的华为自研H.265视频编码器。HW265支持四个预设编码档位可选，对应不同编码速度的应用场景，码率控制支持平均比特率模式（ABR）和恒定QP模式（CQP），功能涵盖直播、点播等各个场景，整体性能优于目前的主流开源软件。",
      "enDesc": "HW265 is a Huawei-developed H.265 video encoder that complies with the H.265/HEVC video encoding standard and uses the NEON instructions of Kunpeng processors for acceleration. HW265 supports four preset encoding levels that correspond to application scenarios with different encoding speeds. The bit rate control supports the average bit rate(ABR) and constant QP(CQP) modes. The functions cover various scenarios such as live TV and VOD. The overall performance of HW265 is better than that of mainstream open source software.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/media",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "HMPP",
      "category id": "4",
      "cnDesc": "鲲鹏超媒体性能库HMPP(Hyper Media Performance Primitives)包括向量缓冲区的分配与释放、向量初始化、向量数学运算与统计学运算、向量采样与向量变换、滤波函数、变换函数(快速傅里叶变换)，支持IEEE 754浮点数运算标准，支持鲲鹏平台下使用。",
      "enDesc": "Kunpeng Hyper Media Performance Primitives(HMPP) prodives functions for allocating and releasing vector buffers, vector initialization, vector mathematical operations, vector statistics operations, vector sampling and conversion, filtering functions, as well as transform(such as fast fourier transform)functions. It complies with the IEEE 754(a technical standard for floating-point arithmetic)and can be used on the Kunpeng platform.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/media",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "KML_FFT",
      "category id": "5",
      "cnDesc": "KML_FFT基于鲲鹏架构，通过向量化、算法改进，对快速离散傅里叶变换进行了深度优化，使得快速傅里叶变换接口函数的性能由大幅度提升。",
      "enDesc": "Based on the Kunpeng architecture, KML_FFT deeply optimizes the fast fourier transform(FFT) by using vectorization and algorithm improvement, which greatly improves the performance of the FFT interface functions.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/math",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "KML_BLAS",
      "category id": "5",
      "cnDesc": "KML_BLAS基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，对BLAS的计算效率进行了深度挖掘，使得BLAS接口函数的性能逼近理论峰值。",
      "enDesc": "Based on the Kunpeng architecture, KML_BLAS performs in-depth mining on the computing efficiency of BLAS by means of vectorization, data prefetch, compilation optimization, and data rearrangement. As a result, the performance of BLAS interface functions approaches the theoretical peak.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/math",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "KML_SPBLAS",
      "category id": "5",
      "cnDesc": "KML_SPBLAS基于鲲鹏架构，充分利用鲲鹏的指令集和架构特点，开发了高性能稀疏矩阵运算库，提升HPC和大数据解决方案业务性能。",
      "enDesc": "Based on the instruction set and architecture features of Kunpeng, KML_SPBLAS develops a high-performance sparse matrix operation library to improve the service performance of HPC and big data solutions.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/math",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "KML_MATH",
      "category id": "5",
      "cnDesc": "KML_MATH通过周期函数规约、算法改进等手段，提供了基于鲲鹏处理器性能提升较大的函数实现。",
      "enDesc": "KML_MATH provides functions with high performance that is based on Kunpeng processors by means of periodic function reduction and algorithm improvement.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/math",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "KML_VML",
      "category id": "5",
      "cnDesc": "KML_VML通过NEON指令优化、内联汇编等方法，对输入数据进行向量化处理，充分利用了鲲鹏架构下的寄存器特点，实现了在鲲鹏处理器上的性能提升。",
      "enDesc": "KML_VML performs vectorization on input data by using methods such as NEON instruction optimization and inline assembly. It uses the register features in the Kunpeng architecture to imporve the performance of Kunpeng processors.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/math",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    },
    {
      "name": "KML_LAPACK",
      "category id": "5",
      "cnDesc": "KML_LAPACK通过分块、求解算法组合、多线程、BLAS接口优化等手段，基于鲲鹏架构对LAPACK的计算效率进行了优化，实现了在鲲鹏处理器上的性能提升。",
      "enDesc": "KML_LAPACK optimizes the LAPACK based on the Kunpeng architecture by means of block division, algorithm combination, multithreading, and Basic Linear Algebra Subprograms(BLAS) interface optimization,  imporving the performance of Kunpeng processors.",
      "kunpeng_url": "https://www.hikunpeng.com/developer/boostkit/library/math",
      "code_url": "软件包暂不支持公开下载，如有需求请发送申请信息至邮箱kunpengcompute@huawei.com"
    }
  ],
  "function": [
    {
      "name": "memcpy",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "内存复制函数",
      "desc_en": "Memory copy function",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "memset",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "内存初始化",
      "desc_en": "Memory initialization",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "memcmp",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "内存比较",
      "desc_en": "Memory comparison",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "memrchr",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "内存初始化",
      "desc_en": "Memory initialization",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "strcpy",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "字符串拷贝",
      "desc_en": "String copy",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "strlen",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "计算字符串长度",
      "desc_en": "Calculates the string length",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "strnlen",
      "library": "glibc_patch",
      "headerfile": "",
      "desc_cn": "计算指定内存区的字符串长度",
      "desc_en": "Calculates the length of a string in a specified memory area",
      "benefit_cn": "使用了Neon指令进行加速优化，已合入gnu社区",
      "benefit_en": "The NEON instructions are used for acceleration and have been incorporated into the GNU community."
    },
    {
      "name": "deflate",
      "library": "gzip",
      "headerfile": "",
      "desc_cn": "gzip工具的压缩接口",
      "desc_en": "Compression interface of the gzip tool",
      "benefit_cn": "使用了指令预取、循环展开实现性能优化",
      "benefit_en": "Instruction prefetch and loop unrolling are used to optimize the performance."
    },
    {
      "name": "inflate",
      "library": "gzip",
      "headerfile": "",
      "desc_cn": "gzip工具的解压接口",
      "desc_en": "Decompression interface of the gzip tool",
      "benefit_cn": "使用了CRC加速指令实现性能优化",
      "benefit_en": "The CRC acceleration instruction is used to optimize the performance."
    },
    {
      "name": "hs_scan",
      "library": "hyperscan",
      "headerfile": "https://gitee.com/kunpengcompute/hyperscan/raw/aarch64/src/hs_runtime.h",
      "desc_cn": "块模式的正则表达式扫描",
      "desc_en": "Regular expression scanning in block mode",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "hs_scan_vector",
      "library": "hyperscan",
      "headerfile": "https://gitee.com/kunpengcompute/hyperscan/raw/aarch64/src/hs_runtime.h",
      "desc_cn": "向量正则表达式扫描",
      "desc_en": "Vector regular expression scanning",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "hs_scan_stream",
      "library": "hyperscan",
      "headerfile": "https://gitee.com/kunpengcompute/hyperscan/raw/aarch64/src/hs_runtime.h",
      "desc_cn": "将待扫描数据写入打开的流中",
      "desc_en": "Write data to be scanned to the opened stream",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "hs_compile",
      "library": "hyperscan",
      "headerfile": "https://gitee.com/kunpengcompute/hyperscan/raw/aarch64/src/hs_compile.h",
      "desc_cn": "导入单个正则表达式",
      "desc_en": "Import a regular expression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "hs_compile_multi",
      "library": "hyperscan",
      "headerfile": "https://gitee.com/kunpengcompute/hyperscan/raw/aarch64/src/hs_compile.h",
      "desc_cn": "导入多个正则表达式",
      "desc_en": "Import multiple regular expressions",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "hs_compile_ext_multi",
      "library": "hyperscan",
      "headerfile": "https://gitee.com/kunpengcompute/hyperscan/raw/aarch64/src/hs_compile.h",
      "desc_cn": "导入多个含扩展参数的正则表达式",
      "desc_en": "Import multiple regular expressions containing extended parameters",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compress",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "zstd块压缩",
      "desc_en": "zstd block compression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompress",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "zstd块解压",
      "desc_en": "zstd block decompression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compressCCtx",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "参数可复用的zstd块压缩接口",
      "desc_en": "zstd block compression interface with reusable parameters",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompressDCtx",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "参数可复用的zstd流解压接口",
      "desc_en": "zstd stream decompression interface with reusable parameters",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compress2",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "参数复用的zstd流解压扩展接口",
      "desc_en": "zstd stream decompression extension interface with reusable parameters",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compressStream",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "zstd流压缩",
      "desc_en": "zstd stream compression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compressStream2",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "zstd流压缩扩展接口",
      "desc_en": "zstd stream compression extension interface",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompressStream",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "zstd流解压",
      "desc_en": "zstd stream decompression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compress_usingDict",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "基于字典的zstd块压缩",
      "desc_en": "Dictionary-based zstd block compression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompress_usingDict",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "基于字典的zstd块解压",
      "desc_en": "Dictionary-based zstd block decompression",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compress_usingCDict",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "基于摘要字典的zstd块压缩",
      "desc_en": "zstd block compression based on the digest dictionary",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompress_usingDDict",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "基于摘要字典的zstd块解压",
      "desc_en": "zstd block decompression based on the digest dictionary",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compressBegin",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "低内存消耗的流压缩初始化接口",
      "desc_en": "Stream compression initialization interface with low memory consumption",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compressContinue",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "低内存消耗的流压缩接口",
      "desc_en": "Stream compression interface with low memory consumption",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_compressEnd",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "低内存消耗的流压缩终止接口",
      "desc_en": "Stream compression termination interface with low memory consumption",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompressBegin",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "低内存消耗的流解压初始化接口",
      "desc_en": "Stream decompression initialization interface with low memory consumption",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "ZSTD_decompressContinue",
      "library": "zstd",
      "headerfile": "https://gitee.com/kunpengcompute/zstd/raw/aarch64-1.4.4/lib/zstd.h",
      "desc_cn": "低内存消耗的流解压接口",
      "desc_en": "Stream decompression interface with low memory consumption",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "snappy_compress",
      "library": "snappy",
      "headerfile": "https://gitee.com/kunpengcompute/snappy/raw/aarch64-1.1.7/snappy-c.h",
      "desc_cn": "块模式压缩接口",
      "desc_en": "Block-mode compression interface",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "snappy_uncompress",
      "library": "snappy",
      "headerfile": "https://gitee.com/kunpengcompute/snappy/raw/aarch64-1.1.7/snappy-c.h",
      "desc_cn": "块模式解压接口",
      "desc_en": "Block-mode decompression interface",
      "benefit_cn": "基于Neon指令实现性能优化",
      "benefit_en": "Performance optimized based on NEON instructions"
    },
    {
      "name": "deflate",
      "library": "KAEzip",
      "headerfile": "https://gitee.com/kunpengcompute/KAEzip/raw/master/include/kaezip.h",
      "desc_cn": "zlib流压缩接口",
      "desc_en": "zlib stream compression interface",
      "benefit_cn": "基于鲲鹏加速器进行性能优化",
      "benefit_en": "Performance optimized based on the Kunpeng accelerator"
    },
    {
      "name": "inflate",
      "library": "KAEzip",
      "headerfile": "https://gitee.com/kunpengcompute/KAEzip/raw/master/include/kaezip.h",
      "desc_cn": "zlib流解压接口",
      "desc_en": "zlib stream decompression interface",
      "benefit_cn": "基于鲲鹏加速器进行性能优化",
      "benefit_en": "Performance optimized based on the Kunpeng accelerator"
    },
    {
      "name": "compress",
      "library": "KAEzip",
      "headerfile": "https://gitee.com/kunpengcompute/KAEzip/raw/master/include/kaezip.h",
      "desc_cn": "zlib块压缩接口",
      "desc_en": "zlib block compression interface",
      "benefit_cn": "基于鲲鹏加速器进行性能优化",
      "benefit_en": "Performance optimized based on the Kunpeng accelerator"
    },
    {
      "name": "compress2",
      "library": "KAEzip",
      "headerfile": "https://gitee.com/kunpengcompute/KAEzip/raw/master/include/kaezip.h",
      "desc_cn": "zlib块压缩扩展接口",
      "desc_en": "zlib block compression extension interface",
      "benefit_cn": "基于鲲鹏加速器进行性能优化",
      "benefit_en": "Performance optimized based on the Kunpeng accelerator"
    },
    {
      "name": "uncompress",
      "library": "KAEzip",
      "headerfile": "https://gitee.com/kunpengcompute/KAEzip/raw/master/include/kaezip.h",
      "desc_cn": "zlib块解压接口",
      "desc_en": "zlib block decompression interface",
      "benefit_cn": "基于鲲鹏加速器进行性能优化",
      "benefit_en": "Performance optimized based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_EncryptInit_ex",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl加密初始化接口",
      "desc_en": "OpenSSL encryption initialization interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_EncryptUpdate",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl加密计算接口",
      "desc_en": "OpenSSL encryption calculation interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_EncryptFinal",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl加密完成接口",
      "desc_en": "OpenSSL encryption completion interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_DecryptInit_ex",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl解密初始化接口",
      "desc_en": "OpenSSL decryption initialization interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_DecryptUpdate",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl解密计算接口",
      "desc_en": "OpenSSL decryption calculation interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_DecryptFinal_ex",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl解密完成接口",
      "desc_en": "OpenSSL decryption completion interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_DigestInit_ex",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl摘要计算初始化接口",
      "desc_en": "OpenSSL digest calculation initialization interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_DigestUpdate",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl摘要计算接口",
      "desc_en": "OpenSSL digest calculation interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_DigestFinal_ex",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl摘要完成接口",
      "desc_en": "OpenSSL digest completion interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "DH_generate_key",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl DH私钥生成接口",
      "desc_en": "OpenSSL DH private key generation interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "DH_compute_key",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl DH计算共享秘钥接口",
      "desc_en": "OpenSSL DH shared key calculation interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "RSA_generate_key_ex",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl RSA秘钥对生成接口",
      "desc_en": "OpenSSL RSA key pairs generation interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_PKEY_encrypt",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl 公钥加密接口",
      "desc_en": "OpenSSL public key encryption interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_PKEY_decrypt",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl 私钥解密接口",
      "desc_en": "OpenSSL private key decryption interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_PKEY_sign",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl 私钥签名接口",
      "desc_en": "OpenSSL private key signature interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "EVP_PKEY_verify",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl 公钥验签接口",
      "desc_en": "OpenSSL public key signature verification interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "RSA_private_decrypt",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl RSA私钥解密接口",
      "desc_en": "OpenSSL RSA private key decryption interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "RSA_private_encrypt",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl RSA私钥加密接口",
      "desc_en": "OpenSSL RSA private key encryption interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "RSA_public_decrypt",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl RSA公钥解密接口",
      "desc_en": "OpenSSL RSA public key decryption interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "RSA_public_encrypt",
      "library": "KAECrypto",
      "headerfile": "https://gitee.com/mirrors/openssl/raw/dda4e259e51aeaf05a2417ef577accf778c9f6f6/include/openssl/evp.h",
      "desc_cn": "openssl RSA公钥加密接口",
      "desc_en": "OpenSSL RSA public key encryption interface",
      "benefit_cn": "基于鲲鹏加速器实现RSA/AES/SM3/SM4/MD5/DH性能加速",
      "benefit_en": "RSA/AES/SM3/SM4/MD5/DH performance accelerated based on the Kunpeng accelerator"
    },
    {
      "name": "vsadd",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型加法函数",
      "desc_en": "Single-precision floating-point real type adds vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdadd",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型加法函数",
      "desc_en": "Double-precision floating-point real type adds vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vssub",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型减法函数",
      "desc_en": "Single-precision floating-point real type subtracts vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdsub",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型减法函数",
      "desc_en": "Double-precision floating-point real type subtracts vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vssqr",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型平方函数",
      "desc_en": "Single-precision floating-point real type squares a vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdsqr",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型平方函数",
      "desc_en": "Double-precision floating-point real type squares a vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsmul",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型乘法函数",
      "desc_en": "Single-precision floating-point real type multiplies vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdmul",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型乘法函数",
      "desc_en": "Double-precision floating-point real type multiplies vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsdiv",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型除法函数",
      "desc_en": "Computes the quotient of single-precision floating-point real type vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vddiv",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型除法函数",
      "desc_en": "Computes the quotient of double-precision floating-point real type vectors",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vssqrt",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型开方函数",
      "desc_en": "Computes the square root of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdsqrt",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型开方函数",
      "desc_en": "Computes the square root of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vspow",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型幂函数",
      "desc_en": "Raises a single-precision floating-point real type vector to the specified power",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdpow",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型幂函数",
      "desc_en": "Raises a double-precision floating-point real type vector to the specified power",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsexp",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型以自然对数为底的指数函数",
      "desc_en": "Computes the base-e exponential of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdexp",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型以自然对数为底的指数函数",
      "desc_en": "Computes the base-e exponential of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsln",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型以自然对数为底的对数函数",
      "desc_en": "Computes the base-e logarithm of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdln",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型以自然对数为底的对数函数",
      "desc_en": "Computes the base-e logarithm of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vslog10",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型以10为底的对数函数",
      "desc_en": "Computes the base-10 logarithm of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdlog10",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型以10为底的对数函数",
      "desc_en": "Computes the base-10 logarithm of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vscos",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型余弦函数",
      "desc_en": "Computes the cosine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdcos",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型余弦函数",
      "desc_en": "Computes the cosine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vssin",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正弦函数",
      "desc_en": "Computes the sine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdsin",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正弦函数",
      "desc_en": "Computes the sine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vstan",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正切函数",
      "desc_en": "Computes the tangent of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdtan",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正切函数",
      "desc_en": "Computes the tangent of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsatan",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdatan",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsatan2",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型两个变量四个象限下的反正切函数",
      "desc_en": "Computes the four-quadrant arc tangent of two variables",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdatan2",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型两个变量四个象限下的反正切函数",
      "desc_en": "Computes the four-quadrant arc tangent of two variables",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vssincos",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正弦函数与余弦函数",
      "desc_en": "Computes the sine and cosine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdsincos",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正弦函数与余弦函数",
      "desc_en": "Computes the sine and cosine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vssinh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdsinh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vscosh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdcosh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vstanh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdtanh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsasinh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲反正弦函数",
      "desc_en": "Computes the hyperbolic arc sine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdasinh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲反正弦函数",
      "desc_en": "Computes the hyperbolic arc sine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsacosh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲反余弦函数",
      "desc_en": "Computes hyperbolic arc cosine of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdacosh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲反余弦函数",
      "desc_en": "Computes the hyperbolic arc cosine of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vsatanh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲反正切函数",
      "desc_en": "Computes the hyperbolic arc tangent of a single-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "vdatanh",
      "library": "KML_VML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲反正切函数",
      "desc_en": "Computes the hyperbolic arc tangent of a double-precision floating-point real type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "sin",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正弦函数",
      "desc_en": "Computes the sine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sinf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正弦函数",
      "desc_en": "Computes the sine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csin",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型正弦函数",
      "desc_en": "Computes the sine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csinf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型正弦函数",
      "desc_en": "Computes the sine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cos",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型余弦函数",
      "desc_en": "Computes the cosine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cosf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型余弦函数",
      "desc_en": "Computes the cosine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ccos",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型余弦函数",
      "desc_en": "Computes the cosine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ccosf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型余弦函数",
      "desc_en": "Computes the cosine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sincos",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正弦、余弦函数",
      "desc_en": "Computes the sine and cosine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sincosf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正弦、余弦函数",
      "desc_en": "Computes the sine and cosine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csincos",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型正弦、余弦函数",
      "desc_en": "Computes the sine and cosine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csincosf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型正弦、余弦函数",
      "desc_en": "Computes the sine and cosine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "tan",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正切函数",
      "desc_en": "Computes the tangent of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "tanf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正切函数",
      "desc_en": "Computes the tangent of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ctan",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型正切函数",
      "desc_en": "Computes the tangent of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ctanf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型正切函数",
      "desc_en": "Computes the tangent of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "asin",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反正弦函数",
      "desc_en": "Computes the arc sine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "asinf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反正弦函数",
      "desc_en": "Computes the arc sine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "casin",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型反正弦函数",
      "desc_en": "Computes the arc sine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "casinf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型反正弦函数",
      "desc_en": "Computes the arc sine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "acos",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反余弦函数",
      "desc_en": "Computes the arc cosine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "acosf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反余弦函数",
      "desc_en": "Computes the arc cosine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cacos",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型反余弦函数",
      "desc_en": "Computes the arc cosine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cacosf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型反余弦函数",
      "desc_en": "Computes the arc cosine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "atan",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "atanf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "catan",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型反正切函数",
      "desc_en": "Computes the arc tangent of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "catanf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型反正切函数",
      "desc_en": "Computes the arc tangent of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "atan2",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "atan2f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "catan2",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型反正切函数",
      "desc_en": "Computes the arc tangent of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "catan2f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型反正切函数",
      "desc_en": "Computes the arc tangent of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sinh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sinhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csinh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csinhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cosh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "coshf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ccosh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ccoshf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "tanh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "tanhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ctanh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ctanhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "asinh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲反正弦函数",
      "desc_en": "Computes the hyperbolic arc sine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "asinhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲反正弦函数",
      "desc_en": "Computes the hyperbolic arc sine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "casinh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型双曲反正弦函数",
      "desc_en": "Computes the hyperbolic arc sine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "casinhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型双曲反正弦函数",
      "desc_en": "Computes the hyperbolic arc sine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "acosh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲反余弦函数",
      "desc_en": "Computes the hyperbolic arc cosine of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "acoshf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲反余弦函数",
      "desc_en": "Computes the hyperbolic arc cosine of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cacosh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型双曲反余弦函数",
      "desc_en": "Computes the hyperbolic arc cosine of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cacoshf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型双曲反余弦函数",
      "desc_en": "Computes the hyperbolic arc cosine of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "atanh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲反正切函数",
      "desc_en": "Computes the hyperbolic arc tangent of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "atanhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲反正切函数",
      "desc_en": "Computes the hyperbolic arc tangent of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "catanh",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型双曲反正切函数",
      "desc_en": "Computes the hyperbolic arc tangent of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "catanhf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型双曲反正切函数",
      "desc_en": "Computes the hyperbolic arc tangent of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "exp",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "expf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cexp",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cexpf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "exp2",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型指数函数(base 2)",
      "desc_en": "Computes the base-2 exponential of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "exp2f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型指数函数(base 2)",
      "desc_en": "Computes the base-2 exponential of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cexp2",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型指数函数(base 2)",
      "desc_en": "Computes the base-2 exponential of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cexp2f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型指数函数(base 2)",
      "desc_en": "Computes the base-2 exponential of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "log",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "logf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "clog",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "clogf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "log2",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型对数函数(base 2)",
      "desc_en": "Computes the base-2 logarithm of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "log2f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型对数函数(base 2)",
      "desc_en": "Computes the base-2 logarithm of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "clog2",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型对数函数(base 2)",
      "desc_en": "Computes the base-2 logarithm of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "clog2f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型对数函数(base 2)",
      "desc_en": "Computes the base-2 logarithm of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "log10",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型对数函数(base 10)",
      "desc_en": "Computes the base-10 logarithm of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "log10f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型对数函数(base 10)",
      "desc_en": "Computes the base-10 logarithm of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "clog10",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型对数函数(base 10)",
      "desc_en": "Computes the base-10 logarithm of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "clog10f",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型对数函数(base 10)",
      "desc_en": "Computes the base-10 logarithm of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "pow",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型幂函数",
      "desc_en": "Raises double-precision floating-point real type x to the specified power",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "powf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型幂函数",
      "desc_en": "Raises single-precision floating-point real type x to the specified power",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cpow",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型幂函数",
      "desc_en": "Raises double-precision floating-point complex type x to the specified power",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cpowf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型幂函数",
      "desc_en": "Raises single-precision floating-point complex type x to the specified power",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sqrt",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型平方根函数",
      "desc_en": "Computes the square root of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "sqrtf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型平方根函数",
      "desc_en": "Computes the square root of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csqrt",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型平方根函数",
      "desc_en": "Computes the square root of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "csqrtf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型平方根函数",
      "desc_en": "Computes the square root of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cbrt",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度浮点类型立方根函数",
      "desc_en": "Computes the cubic root of double-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "cbrtf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度浮点类型立方根函数",
      "desc_en": "Computes the cubic root of single-precision floating-point real type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ccbrt",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "双精度复数类型立方根函数",
      "desc_en": "Computes the cubic root of double-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "ccbrtf",
      "library": "KML_MATH",
      "headerfile": "",
      "desc_cn": "单精度复数类型立方根函数",
      "desc_en": "Computes the cubic root of single-precision floating-point complex type x",
      "benefit_cn": "通过周期函数规约、算法改进等手段，提供了基于鲲鹏芯片性能提升较大的函数实现",
      "benefit_en": "Provides functions with high performance that is based on Kunpeng processors by means of Periodic function range reduction and algorithm improvement"
    },
    {
      "name": "svml128_sin_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正弦函数",
      "desc_en": "Computes the sine of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_sin_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正弦函数",
      "desc_en": "Computes the sine of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_cos_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型余弦函数",
      "desc_en": "Computes the cosine of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_cos_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型余弦函数",
      "desc_en": "Computes the cosine of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_sincos_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正弦、余弦函数",
      "desc_en": "Computes the sine and cosine of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_sincos_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正弦、余弦函数",
      "desc_en": "Computes the sine and cosine of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_tan_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型正切函数",
      "desc_en": "Computes the tangent of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_tan_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型正切函数",
      "desc_en": "Computes the tangent of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_atan_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_atan_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_atan2_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_atan2_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型反正切函数",
      "desc_en": "Computes the arc tangent of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_sinh_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_sinh_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲正弦函数",
      "desc_en": "Computes the hyperbolic sine of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_cosh_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_cosh_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲余弦函数",
      "desc_en": "Computes the hyperbolic cosine of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_tanh_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_tanh_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型双曲正切函数",
      "desc_en": "Computes the hyperbolic tangent of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_exp_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_exp_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_exp2_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型指数函数(base 2)",
      "desc_en": "Computes the base-2 exponential of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_exp2_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型指数函数(base 2)",
      "desc_en": "Computes the base-2 exponential of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_expm1_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_expm1_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型指数函数(base e)",
      "desc_en": "Computes the base-e exponential of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_log_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_log_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_log10_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型对数函数(base 10)",
      "desc_en": "Computes the base-10 logarithm of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_log10_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型对数函数(base 10)",
      "desc_en": "Computes the base-10 logarithm of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_log1p_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of single-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_log1p_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型对数函数(base e)",
      "desc_en": "Computes the base-e logarithm of double-precision floating-point type vector",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_pow_f32",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "单精度浮点类型幂函数",
      "desc_en": "Raises single-precision floating-point type vector to the specified power",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "svml128_pow_f64",
      "library": "KML_SVML",
      "headerfile": "",
      "desc_cn": "双精度浮点类型幂函数",
      "desc_en": "Raises double-precision floating-point type vector to the specified power",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "cblas_saxpy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量缩放与加和",
      "desc_en": "Vector scaling and summation",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_daxpy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量缩放与加和",
      "desc_en": "Vector scaling and summation",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_caxpy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量缩放与加和",
      "desc_en": "Vector scaling and summation",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zaxpy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量缩放与加和",
      "desc_en": "Vector scaling and summation",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sasum",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量元素绝对值求和",
      "desc_en": "Sum of absolute values of vector elements",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dasum",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量元素绝对值求和",
      "desc_en": "Sum of absolute values of vector elements",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_casum",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量元素绝对值求和",
      "desc_en": "Sum of absolute values of vector elements",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zasum",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量元素绝对值求和",
      "desc_en": "Sum of absolute values of vector elements",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_scopy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量拷贝",
      "desc_en": "Vector copy",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dcopy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量拷贝",
      "desc_en": "Vector copy",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ccopy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量拷贝",
      "desc_en": "Vector copy",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zcopy",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量拷贝",
      "desc_en": "Vector copy",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sdot",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量点积",
      "desc_en": "Vector dot product",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ddot",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量点积",
      "desc_en": "Vector dot product",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cdotc",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型共轭向量与另一向量的点积",
      "desc_en": "Dot product of a conjugate vector and another vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zdotc",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型共轭向量与另一向量的点积",
      "desc_en": "Dot product of a conjugate vector and another vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cdotu",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数向量点积",
      "desc_en": "Complex vector dot product",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zdotu",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数向量点积",
      "desc_en": "Complex vector dot product",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ssdot",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型扩展精度点积",
      "desc_en": "Extended precision dot product",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsdot",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型扩展精度点积",
      "desc_en": "Extended precision dot product",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_isamax",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量中最大绝对值的索引",
      "desc_en": "Index of the maximum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_idamax",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量中最大绝对值的索引",
      "desc_en": "Index of the maximum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_icamax",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量中最大绝对值的索引",
      "desc_en": "Index of the maximum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_izamax",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量中最大绝对值的索引",
      "desc_en": "Index of the maximum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_isamin",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量中最小绝对值的索引",
      "desc_en": "Index of the minimum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_idamin",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量中最小绝对值的索引",
      "desc_en": "Index of the minimum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_icamin",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量中最小绝对值的索引",
      "desc_en": "Index of the minimum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_izamin",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量中最小绝对值的索引",
      "desc_en": "Index of the minimum absolute value in the vector",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_snrm2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "计算欧几里得范数",
      "desc_en": "Euclidean norm",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dnrm2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "计算欧几里得范数",
      "desc_en": "Euclidean norm",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cnrm2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "计算欧几里得范数",
      "desc_en": "Euclidean norm",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_znrm2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "计算欧几里得范数",
      "desc_en": "Euclidean norm",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_srot",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型基于平面上点旋转",
      "desc_en": "Dot rotation based on the plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_drot",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型基于平面上点旋转",
      "desc_en": "Dot rotation based on the plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_srotg",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型构造旋转平面",
      "desc_en": "Constructs the rotating plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_drotg",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型构造旋转平面",
      "desc_en": "Constructs the rotating plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_srotm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型修改旋转平面",
      "desc_en": "Modifies the rotation plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_drotm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型修改旋转平面",
      "desc_en": "Modifies the rotation plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_srotmg",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型构造修改的旋转平面",
      "desc_en": "Constructs the modified conversion plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_drotmg",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型构造修改的旋转平面",
      "desc_en": "Constructs the modified conversion plane",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sscal",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量缩放",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dscal",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量缩放",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cscal",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量缩放",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zscal",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量缩放",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_csscal",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量缩放",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zdscal",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量缩放",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sswap",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型两个向量元素交换",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dswap",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型两个向量元素交换",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cswap",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型两个向量元素交换",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zswap",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型两个向量元素交换",
      "desc_en": "Vector scaling",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sgbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量与带状矩阵乘积",
      "desc_en": "Product of a vector and a band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dgbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量与带状矩阵乘积",
      "desc_en": "Product of a vector and a band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cgbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与带状矩阵乘积",
      "desc_en": "Product of a vector and a band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zgbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与带状矩阵乘积",
      "desc_en": "Product of a vector and a band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sgemv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型向量与矩阵乘积",
      "desc_en": "Product of a vector and a matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dgemv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型向量与矩阵乘积",
      "desc_en": "Product of a vector and a matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cgemv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与矩阵乘积",
      "desc_en": "Product of a vector and a matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zgemv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与矩阵乘积",
      "desc_en": "Product of a vector and a matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_sger",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度浮点类型一般矩阵秩1更新",
      "desc_en": "General matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dger",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度浮点类型一般矩阵秩1更新",
      "desc_en": "General matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cgerc",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "一般单精度复数矩阵秩1更新",
      "desc_en": "General complex matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zgerc",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "一般双精度复数矩阵秩1更新",
      "desc_en": "General complex matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_cgeru",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型一般共轭矩阵秩1更新",
      "desc_en": "General conjugate matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zgeru",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型一般共轭矩阵秩1更新",
      "desc_en": "General conjugate matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_chbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与埃尔米特带状矩阵乘积",
      "desc_en": "Product of a vector and a Hermitian band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zhbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与埃尔米特带状矩阵乘积",
      "desc_en": "Product of a vector and a Hermitian band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_chemv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与埃尔米特矩阵乘积",
      "desc_en": "Product of a vector and a Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zhemv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与埃尔米特矩阵乘积",
      "desc_en": "Product of a vector and a Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_cher",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数埃尔米特矩阵秩1更新",
      "desc_en": "Complex Hermitian matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zher",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数埃尔米特矩阵秩1更新",
      "desc_en": "Complex Hermitian matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_cher2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数埃尔米特矩阵秩2更新",
      "desc_en": "Complex Hermitian matrix rank 2 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zher2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数埃尔米特矩阵秩2更新",
      "desc_en": "Complex Hermitian matrix rank 2 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_chpmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数向量与压缩的埃尔米特矩阵乘积",
      "desc_en": "Product of vector and compressed Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zhpmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数向量与压缩的埃尔米特矩阵乘积",
      "desc_en": "Product of vector and compressed Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_chpr",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "三角展开的埃尔米特矩阵秩1更新",
      "desc_en": "Rank 1 update of triangularly expanded Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zhpr",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "三角展开的埃尔米特矩阵秩1更新",
      "desc_en": "Rank 1 update of triangularly expanded Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_chpr2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "三角展开的埃尔米特矩阵秩2更新",
      "desc_en": "Rank 2 update of triangularly expanded Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zhpr2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "三角展开的埃尔米特矩阵秩2更新",
      "desc_en": "Rank 2 update of triangularly expanded Hermitian matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度向量与对称带状矩阵乘积",
      "desc_en": "Product of a vector and a symmetric band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度向量与对称带状矩阵乘积",
      "desc_en": "Product of a vector and a symmetric band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_sspmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度向量与压缩的对称矩阵乘积",
      "desc_en": "Product of vector and compressed symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dspmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度向量与压缩的对称矩阵乘积",
      "desc_en": "Product of vector and compressed symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_sspr",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "对称展开矩阵秩1更新",
      "desc_en": "Rank 1 update of symmetric expansion matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dspr",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "对称展开矩阵秩1更新",
      "desc_en": "Rank 1 update of symmetric expansion matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_sspr2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "对称展开矩阵秩2更新",
      "desc_en": "Rank 2 update of symmetric expansion matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dspr2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "对称展开矩阵秩2更新",
      "desc_en": "Rank 2 update of symmetric expansion matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssymv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度向量与对称矩阵乘积",
      "desc_en": "Product of a vector and a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsymv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度向量与对称矩阵乘积",
      "desc_en": "Product of a vector and a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssyr",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度对称矩阵秩1更新",
      "desc_en": "Symmetric matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsyr",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度对称矩阵秩1更新",
      "desc_en": "Symmetric matrix rank 1 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssyr2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度对称矩阵秩2更新",
      "desc_en": "Symmetric matrix rank 2 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsyr2",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度对称矩阵秩2更新",
      "desc_en": "Symmetric matrix rank 2 update",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_stbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型向量与三角带状矩阵乘积",
      "desc_en": "Product of a vector and a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型向量与三角带状矩阵乘积",
      "desc_en": "Product of a vector and a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ctbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与三角带状矩阵乘积",
      "desc_en": "Product of a vector and a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztbmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与三角带状矩阵乘积",
      "desc_en": "Product of a vector and a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_stbsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型线性方程组求解，稀疏矩阵为三角带状矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtbsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型线性方程组求解，稀疏矩阵为三角带状矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ctbsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型线性方程组求解，稀疏矩阵为三角带状矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztbsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型线性方程组求解，稀疏矩阵为三角带状矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular band matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_stpmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型向量与压缩的三角矩阵乘积",
      "desc_en": "Product of vector and compressed triangular mstrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtpmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型向量与压缩的三角矩阵乘积",
      "desc_en": "Product of vector and compressed triangular mstrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ctpmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与压缩的三角矩阵乘积",
      "desc_en": "Product of vector and compressed triangular mstrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztpmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与压缩的三角矩阵乘积",
      "desc_en": "Product of vector and compressed triangular mstrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_stpsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型线性方程组求解，稀疏矩阵是压缩的三角矩阵",
      "desc_en": "For solving linear equations, the sparse matrix is a compressed triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtpsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型线性方程组求解，稀疏矩阵是压缩的三角矩阵",
      "desc_en": "For solving linear equations, the sparse matrix is a compressed triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ctpsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型线性方程组求解，稀疏矩阵是压缩的三角矩阵",
      "desc_en": "For solving linear equations, the sparse matrix is a compressed triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztpsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型线性方程组求解，稀疏矩阵是压缩的三角矩阵",
      "desc_en": "For solving linear equations, the sparse matrix is a compressed triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_strmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型向量与三角矩阵乘积",
      "desc_en": "Product of a vector and a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtrmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型向量与三角矩阵乘积",
      "desc_en": "Product of a vector and a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ctrmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量与三角矩阵乘积",
      "desc_en": "Product of a vector and a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztrmv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量与三角矩阵乘积",
      "desc_en": "Product of a vector and a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_strsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型线性方程组求解，稀疏矩阵是三角矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtrsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型线性方程组求解，稀疏矩阵是三角矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ctrsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型线性方程组求解，稀疏矩阵是三角矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztrsv",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型线性方程组求解，稀疏矩阵是三角矩阵",
      "desc_en": "Solves linear equations. The sparse matrix is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_sgemm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型一般矩阵乘矩阵",
      "desc_en": "General matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dgemm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型一般矩阵乘矩阵",
      "desc_en": "General matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_cgemm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型一般矩阵乘矩阵",
      "desc_en": "General matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zgemm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型一般矩阵乘矩阵",
      "desc_en": "General matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_chemm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型埃尔米特矩阵乘积",
      "desc_en": "Complex Hermitian moment-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zhemm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型埃尔米特矩阵乘积",
      "desc_en": "Complex Hermitian moment-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_cher2k",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵乘矩阵秩2更新，矩阵C为复数埃尔米特矩阵",
      "desc_en": "Complex matrix-matrix multiplication rank 2 update. The matrix C is a complex Hermitian moment",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zher2k",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵乘矩阵秩2更新，矩阵C为复数埃尔米特矩阵",
      "desc_en": "Complex matrix-matrix multiplication rank 2 update. The matrix C is a complex Hermitian moment",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_cherk",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵乘矩阵秩k更新，矩阵C为单精度复数埃尔米特矩阵",
      "desc_en": "Complex matrix-matrix multiplication rank k update. The matrix C is a float-complex Hermitian moment",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zherk",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵乘矩阵秩k更新，矩阵C为双精度复数埃尔米特矩阵",
      "desc_en": "Complex matrix-matrix multiplication rank k update. The matrix C is a double-complex Hermitian moment",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssymm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型对称矩阵乘矩阵",
      "desc_en": "Symmetric matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsymm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型对称矩阵乘矩阵",
      "desc_en": "Symmetric matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_csymm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型对称矩阵乘矩阵",
      "desc_en": "Symmetric matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zsymm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型对称矩阵乘矩阵",
      "desc_en": "Symmetric matrix-matrix multiplication",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssyrk",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型矩阵乘矩阵秩K更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank k update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsyrk",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型矩阵乘矩阵秩K更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank k update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_csyrk",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵乘矩阵秩K更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank k update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zsyrk",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵乘矩阵秩K更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank k update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_ssyr2k",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型矩阵乘矩阵秩2更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank 2 update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dsyr2k",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型矩阵乘矩阵秩2更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank 2 update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
     {
      "name": "cblas_csyr2k",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵乘矩阵秩2更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank 2 update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zsyr2k",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵乘矩阵秩2更新，矩阵C为对称矩阵",
      "desc_en": "Matrix-matrix multiplication rank 2 update. The matrix C is a symmetric matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_strmm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型矩阵乘矩阵,其中一个矩阵为三角矩阵",
      "desc_en": "Matrix-matrix multiplication. One of the matrices is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtrmm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型矩阵乘矩阵,其中一个矩阵为三角矩阵",
      "desc_en": "Matrix-matrix multiplication. One of the matrices is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
     {
      "name": "cblas_ctrmm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵乘矩阵,其中一个矩阵为三角矩阵",
      "desc_en": "Matrix-matrix multiplication. One of the matrices is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztrmm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵乘矩阵,其中一个矩阵为三角矩阵",
      "desc_en": "Matrix-matrix multiplication.One of the matrices is a triangular matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_strsm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型三角矩阵方程求解",
      "desc_en": "Triangular matrix equation solution",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_dtrsm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型三角矩阵方程求解",
      "desc_en": "Triangular matrix equation solution",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
     {
      "name": "cblas_ctrsm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型三角矩阵方程求解",
      "desc_en": "Triangular matrix equation solution",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_ztrsm",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型三角矩阵方程求解",
      "desc_en": "Triangular matrix equation solution",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_saxpby",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度类型向量分别缩放与加和",
      "desc_en": "Vector scaling and summation separately",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_daxpby",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度类型向量分别缩放与加和",
      "desc_en": "Vector scaling and summation separately",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_caxpby",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型向量分别缩放与加和",
      "desc_en": "Vector scaling and summation separately",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zaxpby",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型向量分别缩放与加和",
      "desc_en": "Vector scaling and summation separately",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "cblas_cgemm3m",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "一般单精度复数矩阵乘矩阵",
      "desc_en": "Product of a general single-precision complex matrix and a matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
	{
      "name": "cblas_zgemm3m",
      "library": "KML_BLAS",
      "headerfile": "",
      "desc_cn": "一般双精度复数矩阵乘矩阵",
      "desc_en": "Product of a general double-precision complex matrix and a matrix",
      "benefit_cn": "基于鲲鹏架构，通过向量化、数据预取、编译优化、数据重排等手段，实现性能优化",
      "benefit_en": "Based on the Kunpeng architecture, performance is optimized through vectorization, data prefetching, compilation optimization, and data rearrangement."
    },
    {
      "name": "kml_sparse_saxpyi",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，稀疏向量与标量相乘，并将结果加到另一向量上",
      "desc_en": "single-precision real type, computes the product of a sparse vector and a scalar and stores the product to another vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供了高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_daxpyi",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，稀疏向量与标量相乘，并将结果加到另一向量上",
      "desc_en": "double-precision real type, computes the product of a sparse vector and a scalar and stores the product to another vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供了高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_caxpyi",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，稀疏向量与标量相乘，并将结果加到另一向量上",
      "desc_en": "single-precision complex type, computes the product of a sparse vector and a scalar and stores the product to another vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zaxpyi",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，稀疏向量与标量相乘，并将结果加到另一向量上",
      "desc_en": "double-precision complex type, computes the product of a sparse vector and a scalar and stores the product to another vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_sdoti",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型稀疏向量点积",
      "desc_en": "Computes the dot product of single-precision real type sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供了高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_ddoti",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型稀疏向量点积",
      "desc_en": "Computes the dot product of double-precision real type sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供了高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_cdotci_sub",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型稀疏向量共轭点积",
      "desc_en": "Computes the dot conjugate product of single-precision complex type sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zdotci_sub",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型稀疏向量共轭点积",
      "desc_en": "Computes the conjugate dot product of double-precision complex type sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_cdotui_sub",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数域稀疏向量非共轭点积",
      "desc_en": "Computes the dot non-conjugate product of single-precision complex sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zdotui_sub",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数域稀疏向量非共轭点积",
      "desc_en": "Computes the non-conjugate dot product of double-precision complex sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_sgthr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，将全存储稀疏向量中的指定元素加载到压缩格式的稀疏向量中",
      "desc_en": "single-precision real type, Gathers the specified elements of a full-storage vector into a compressed sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_dgthr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，将全存储向量中的指定元素加载到压缩格式的稀疏向量中",
      "desc_en": "double-precision real type, Gathers the specified elements of a full-storage vector into a compressed sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_cgthr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，将全存储向量中的指定元素加载到压缩格式的稀疏向量中",
      "desc_en": "single-precision complex type, Gathers the specified elements of a full-storage vector into a compressed sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zgthr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，将全存储稀疏向量中的指定元素加载到压缩格式的向量中",
      "desc_en": "double-precision complex type, Gathers the specified elements of a full-storage sparse vector into a compressed vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_sgthrz",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，将全存储向量中的指定元素加载到压缩格式的向量中，并将全存储向量元素清零",
      "desc_en": "single-precision real type, Gathers the specified elements of a full-storage vector into a compressed sparse vector, and zeroes out these elements in the full-storage vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_dgthrz",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，将全存储向量中的指定元素加载到压缩格式的稀疏向量中，并将全存储向量元素清零",
      "desc_en": "double-precision real type, Gathers the specified elements of a full-storage vector into a compressed sparse vector, and zeroes out these elements in the full-storage vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_cgthrz",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，将全存储向量中的指定元素加载到压缩格式的稀疏向量中，并将全存储向量元素清零",
      "desc_en": "single-precision complex type, Gathers the specified elements of a full-storage vector into a compressed sparse vector, and zeroes out these elements in the full-storage vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zgthrz",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，将全存储向量中的指定元素加载到压缩格式的稀疏向量中，并将全存储向量元素清零",
      "desc_en": "double-precision complex type, Gathers the specified elements of a full-storage vector into a compressed sparse vector, and zeroes out these elements in the full-storage vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_sroti",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "对两个单精度实数类型稀疏向量进行旋转",
      "desc_en": "Rotates two single-precision real type sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_droti",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "对两个双精度实数类型稀疏向量进行旋转",
      "desc_en": "Rotates two double-precision real type sparse vectors",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_ssctr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "将压缩格式的单精度类型向量写入全存储稀疏向量的指定位置",
      "desc_en": "Writes a compressed single-precision type vector to the specified location of a full-storage sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_dsctr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "将压缩格式的双精度类型向量写入全存储稀疏向量的指定位置",
      "desc_en": "Writes a compressed double-precision type vector to the specified location of a full-storage sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_csctr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "将压缩格式的单精度复数类型向量写入全存储稀疏向量的指定位置",
      "desc_en": "Writes a compressed single-precision complex type vector to the specified location of a full-storage sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zsctr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "将压缩格式的双精度复数类型向量写入全存储稀疏向量的指定位置",
      "desc_en": "Writes a compressed double-precision complex type vector to the specified location of a full-storage sparse vector",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏通常矩阵",
      "desc_en": "single-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_dcsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏通常矩阵",
      "desc_en": "double-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_ccsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏通常矩阵",
      "desc_en": "single-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zcsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏通常矩阵",
      "desc_en": "double-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "single-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_dcsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "double-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_ccsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "single-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zcsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "double-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "single-precision real type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_dcsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "double-precision real type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_ccsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "single-precision complex type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_zcsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基1索引的稀疏对称矩阵",
      "desc_en": "double-precision complex type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with one-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_scsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏通常矩阵",
      "desc_en": "single-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏通常矩阵",
      "desc_en": "double-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏通常矩阵",
      "desc_en": "single-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrgemv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏通常矩阵",
      "desc_en": "double-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse general matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_scsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "single-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "double-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "single-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrsymv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与向量乘积，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "double-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_scsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "single-precision real type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "double-precision real type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "single-precision complex type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrtrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，求解三角矩阵方程组计算，矩阵是CSR格式(三数组)基0索引的稀疏对称矩阵",
      "desc_en": "double-precision complex type, Triangular matrix equation solution. The matrix is a sparse symmetric matrix stored in the CSR format(3-array variation) with zero-based indexing",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与向量乘积，矩阵是CSR格式的稀疏矩阵",
      "desc_en": "single-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse matrix stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与向量乘积，矩阵是CSR格式的稀疏矩阵",
      "desc_en": "double-precision real type, Computes the product of a matrix and a vector. The matrix is a sparse matrix stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与向量乘积，矩阵是CSR格式的稀疏矩阵",
      "desc_en": "single-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse matrix stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与向量乘积，矩阵是CSR格式的稀疏矩阵",
      "desc_en": "double-precision complex type, Computes the product of a matrix and a vector. The matrix is a sparse matrix stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSR",
      "desc_en": "single-precision real type, Solves a system of linear equations for a sparse matrix that is stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSR",
      "desc_en": "double-precision real type, Solves a system of linear equations for a sparse matrix that is stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型求解稀疏线性方程组，稀疏矩阵存储格式为CSR",
      "desc_en": "single-precision complex type, Solves a system of linear equations for a sparse matrix that is stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSR",
      "desc_en": "double-precision complex type, Solves a system of linear equations for a sparse matrix that is stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，计算CSR格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "single-precision real type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，计算CSR格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "double-precision real type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，计算CSR格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "single-precision complex type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，计算CSR格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "double-precision complex type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scscmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与向量乘积，矩阵是CSC格式的稀疏矩阵",
      "desc_en": "single-precision real type, Computes the product of a matrix and a vector. The natrix is a sparse matrix stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcscmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与向量乘积，矩阵是CSC格式的稀疏矩阵",
      "desc_en": "double-precision real type, Computes the product of a matrix and a vector. The natrix is a sparse matrix stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccscmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与向量乘积，矩阵是CSC格式的稀疏矩阵",
      "desc_en": "single-precision complex type, Computes the product of a matrix and a vector. The natrix is a sparse matrix stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcscmv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与向量乘积，矩阵是CSC格式的稀疏矩阵",
      "desc_en": "double-precision complex type, Computes the product of a matrix and a vector. The natrix is a sparse matrix stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scscsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSC",
      "desc_en": "single-precision real type, Solves a system of linear equations for a sparse matrix that is stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcscsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSC",
      "desc_en": "double-precision real type, Solves a system of linear equations for a sparse matrix that is stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccscsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSC",
      "desc_en": "single-precision complex type, Solves a system of linear equations for a sparse matrix that is stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcscsv",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，求解稀疏线性方程组，稀疏矩阵存储格式为CSC",
      "desc_en": "double-precision complex type, Solves a system of linear equations for a sparse matrix that is stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scscmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，计算CSC格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "single-precision real type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcscmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，计算CSC格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "double-precision real type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccscmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，计算CSC格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "single-precision complex type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcscmm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，计算CSC格式的稀疏矩阵和稠密矩阵的积",
      "desc_en": "double-precision complex type, Computes the product of a sparse matrix and a dense matrix that are stored in the CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSR格式",
      "desc_en": "single-precision real type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSR格式",
      "desc_en": "double-precision real type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSR格式",
      "desc_en": "single-precision complex type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSR格式",
      "desc_en": "double-precision complex type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSR format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scscsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSC格式",
      "desc_en": "single-precision real type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcscsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSC格式",
      "desc_en": "double-precision real type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccscsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSC格式",
      "desc_en": "single-precision complex type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcscsm",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，求解多个右端顶的稀疏线性方程组，矩阵式CSC格式",
      "desc_en": "double-precision complex type, Solving a sparse system of linear equations with multiple right-hand terms, the matrix is in CSC format",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsradd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与矩阵相加，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "single-precision real type, Computes the sum of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsradd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与矩阵相加，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "double-precision real type, Computes the sum of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsradd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与矩阵相加，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "single-precision complex type, Computes the sum of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsradd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与矩阵相加，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "double-precision complex type, Computes the sum of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrmultcsr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "single-precision real type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrmultcsr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "double-precision real type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrmultcsr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "single-precision complex type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrmultcsr",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稀疏矩阵",
      "desc_en": "double-precision complex type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a sparse matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_sparse_scsrmultd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度实数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稠密矩阵",
      "desc_en": "single-precision real type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a dense matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_dcsrmultd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度实数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稠密矩阵",
      "desc_en": "double-precision real type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a dense matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_ccsrmultd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "单精度复数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稠密矩阵",
      "desc_en": "single-precision complex type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a dense matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_csparse_zcsrmultd",
      "library": "KML_SPBLAS",
      "headerfile": "",
      "desc_cn": "双精度复数类型，矩阵与矩阵相乘，矩阵是CSR格式(三数组，矩阵index从1开始)的稀疏矩阵，结果存储在稠密矩阵",
      "desc_en": "double-precision complex type, Computes the product of two sparse matrices that are stored in the CSR format(3-array variation)with one-based indexing.The result is stored in a dense matrix",
      "benefit_cn": "基于鲲鹏架构为压缩格式的稀疏矩阵提供高性能向量、矩阵运算",
      "benefit_en": "Based on the Kunpeng architecture provides high-performance vector and matrix operations for sparse matrices in compressed formats"
    },
    {
      "name": "kml_fft_plan_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列n维C2C变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列n维C2C变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列1维C2C变换的plan",
      "desc_en": "double-precision type, create a plan for the one-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列1维C2C变换的plan",
      "desc_en": "single-precision type, create a plan for the one-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列2维C2C变换的plan",
      "desc_en": "double-precision type, create a plan for the two-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列2维C2C变换的plan",
      "desc_en": "single-precision type, create a plan for the two-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列3维C2C变换的plan",
      "desc_en": "double-precision type, create a plan for the three-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列3维C2C变换的plan",
      "desc_en": "single-precision type, create a plan for the three-dimensional complex-to-complex(C2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_split_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_split_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_split_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_split_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of a multiple data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_many_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立howmany组数据序列n维C2C变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_many_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立howmany组数据序列n维C2C变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-complex(C2C)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列n维R2C变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列n维R2C变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2c_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列1维R2C变换的plan",
      "desc_en": "double-precision type, create a plan for the one-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2c_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列1维R2C变换的plan",
      "desc_en": "single-precision type, create a plan for the one-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2c_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列2维R2C变换的plan",
      "desc_en": "double-precision type, create a plan for the two-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2c_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列2维R2C变换的plan",
      "desc_en": "single-precision type, create a plan for the two-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2c_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列3维R2C变换的plan",
      "desc_en": "double-precision type, create a plan for the three-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2c_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列3维R2C变换的plan",
      "desc_en": "single-precision type, create a plan for the three-dimensional real-to-complex(R2C)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_split_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_split_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_split_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_split_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维R2C变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of a multiple data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_many_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立howmany组数据序列n维R2C变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_many_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立howmany组数据序列n维R2C变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-complex(R2C)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列n维c2r变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-real(c2r)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列n维C2R变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_c2r_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列1维C2R变换的plan",
      "desc_en": "double-precision type, create a plan for the one-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_c2r_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列1维C2R变换的plan",
      "desc_en": "single-precision type, create a plan for the one-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_c2r_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列2维C2R变换的plan",
      "desc_en": "double-precision type, create a plan for the two-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_c2r_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列2维C2R变换的plan",
      "desc_en": "single-precision type, create a plan for the two-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_c2r_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列3维C2R变换的plan",
      "desc_en": "double-precision type, create a plan for the three-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_c2r_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列3维C2R变换的plan",
      "desc_en": "single-precision type, create a plan for the three-dimensional complex-to-real(C2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_split_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_split_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_split_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_split_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维C2R变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of a multiple data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_many_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立howmany组数据序列n维C2R变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_many_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立howmany组数据序列n维C2R变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional complex-to-real(C2R)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列n维R2R变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列n维R2R变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2r_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列1维R2R变换的plan",
      "desc_en": "double-precision type, create a plan for the one-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2r_1d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列1维R2R变换的plan",
      "desc_en": "single-precision type, create a plan for the one-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2r_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列2维R2R变换的plan",
      "desc_en": "double-precision type, create a plan for the two-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2r_2d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列2维R2R变换的plan",
      "desc_en": "single-precision type, create a plan for the two-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_dft_r2r_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立单个连续数据序列3维R2R变换的plan",
      "desc_en": "double-precision type, create a plan for the three-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_dft_r2r_3d",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立单个连续数据序列3维R2R变换的plan",
      "desc_en": "single-precision type, create a plan for the three-dimensional real-to-real(R2R)transform of a single contiguous data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维R2R变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维R2R变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_guru64_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立多组数据序列n维R2R变换的plan。",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_guru64_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立多组数据序列n维R2R变换的plan。",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of a multiple data sequence.",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_many_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,建立howmany组数据序列n维R2R变换的plan",
      "desc_en": "double-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_many_dft_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,建立howmany组数据序列n维R2R变换的plan",
      "desc_en": "single-precision type, create a plan for the n-dimensional real-to-real(R2R)transform of howmany data sequence",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_r2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_split_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_split_dft",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_split_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_split_dft_r2c",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_execute_split_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,执行之前建立的FFT变换plan",
      "desc_en": "double-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_execute_split_dft_c2r",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,执行之前建立的FFT变换plan",
      "desc_en": "single-precision type, executes the created FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_malloc",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型,分配所需内存空间",
      "desc_en": "double-precision type, allocate the required memory space",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_malloc",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型,分配所需内存空间",
      "desc_en": "single-precision type, allocate the required memory space",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_free",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "释放由kml_fft_malloc函数申请的内存",
      "desc_en": "Release the memory space applied using the kml_fft_malloc function",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_free",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "释放由kml_fftf_malloc函数申请的内存",
      "desc_en": "Release the memory space applied using the kml_fftf_malloc function",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_destroy_plan",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型，释放FFT变换plan的所有内存",
      "desc_en": "double-precision type, Release all the memory space used by an FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_destroy_plan",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型，释放FFT变换plan的所有内存",
      "desc_en": "single-precision type, Release all the memory space used by an FFT plan",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_init_threads",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型，初始化线程",
      "desc_en": "double-precision type, initialize thread",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_init_threads",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型，初始化线程",
      "desc_en": "single-precision type, initialize thread",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_plan_with_threads",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型，指定FFT库接口函数执行的线程数",
      "desc_en": "double-precision type, specify the number of threads executed by the FFT library interface function",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_plan_with_threads",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型，指定FFT库接口函数执行的线程数",
      "desc_en": "single-precision type, specify the number of threads executed by the FFT library interface function",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fft_cleanup_threads",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "双精度类型，释放多线程框架相关的资源",
      "desc_en": "double-precision type, release resources related the multi-thread framework",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "kml_fftf_cleanup_threads",
      "library": "KML_FFT",
      "headerfile": "",
      "desc_cn": "单精度类型，释放多线程框架相关的资源",
      "desc_en": "single-precision type, release resources related the multi-thread framework",
      "benefit_cn": "通过Neon指令优化、内联汇编等方法，充分利用鲲鹏架构下的寄存器特点，实现了在鲲鹏服务器上的性能提升",
      "benefit_en": "Using methods such as NEON instruction optimization and inline assembly. It makes full use of register features in the Kunpeng architecture to improve performance of Kunpeng servers"
    },
    {
      "name": "sgetrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "单精度实数类型矩阵的LU分解",
      "desc_en": "LU factorization of single precision real type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵LU分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix LU factorization performance"
    },
    {
      "name": "dgetrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度实数类型矩阵的LU分解",
      "desc_en": "LU factorization of double precision real type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵LU分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix LU factorization performance"
    },
    {
      "name": "cgetrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵的LU分解",
      "desc_en": "LU factorization of single precision complex type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵LU分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix LU factorization performance"
    },
    {
      "name": "zgetrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵的LU分解",
      "desc_en": "LU factorization of double precision complex type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵LU分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix LU factorization performance"
    },
    {
      "name": "sgeqrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "单精度实数类型矩阵的QR分解",
      "desc_en": "QR factorization of single precision real type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵QR分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix QR factorization performance"
    },
    {
      "name": "dgeqrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度实数类型矩阵的QR分解",
      "desc_en": "QR factorization of double precision real type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵QR分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix QR factorization performance"
    },
    {
      "name": "cgeqrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "单精度复数类型矩阵的QR分解",
      "desc_en": "QR factorization of single precision complex type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵QR分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix QR factorization performance"
    },
    {
      "name": "zgeqrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度复数类型矩阵的QR分解",
      "desc_en": "QR factorization of double precision complex type matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵QR分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix QR factorization performance"
    },
    {
      "name": "spotrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "单精度实对称正定矩阵的Cholesky分解",
      "desc_en": "Cholesky decomposition of single precision real symmetric positive definite matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵Cholesky分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix Cholesky decomposition performance"
    },
    {
      "name": "dpotrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度实对称正定矩阵的Cholesky分解",
      "desc_en": "Cholesky decomposition of double precision real symmetric positive definite matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵Cholesky分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix Cholesky decomposition performance"
    },
    {
      "name": "cpotrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "单精度Hermite正定矩阵的Cholesky分解",
      "desc_en": "Cholesky decomposition of single precision Hermite positive definite matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵Cholesky分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix Cholesky decomposition performance"
    },
    {
      "name": "zpotrf",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度Hermite正定矩阵的Cholesky分解",
      "desc_en": "Cholesky decomposition of double precision Hermite positive definite matrices",
      "benefit_cn": "基于鲲鹏框架，实现矩阵Cholesky分解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates matrix Cholesky decomposition performance"
    },
    {
      "name": "sppsv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为单精度实对称正定矩阵，并以压缩格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a single precision real symmetric positive definite matrix and packed storage",
      "benefit_cn": "基于鲲鹏框架，实现对称正定矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with symmetric positive definite matrices"
    },
    {
      "name": "dppsv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为双精度实对称正定矩阵，并以压缩格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a double precision real symmetric positive definite matrix and packed storage",
      "benefit_cn": "基于鲲鹏框架，实现对称正定矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with symmetric positive definite matrices"
    },
    {
      "name": "cppsv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为单精度Hermite正定矩阵，并以压缩格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a single precision Hermite positive definite matrix and packed storage",
      "benefit_cn": "基于鲲鹏框架，实现对称正定矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with symmetric positive definite matrices"
    },
    {
      "name": "zppsv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为双精度Hermite正定矩阵，并以压缩格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a double precision real symmetric positive definite matrix and packed storage",
      "benefit_cn": "基于鲲鹏框架，实现对称正定矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with symmetric positive definite matrices"
    },
    {
      "name": "sgesv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为一般单精度实矩阵，并以完全格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a single precision real general matrix and full storage",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with general matrices"
    },
    {
      "name": "dgesv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为一般双精度实矩阵，并以完全格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a double precision real general matrix and full storage",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with general matrices"
    },
    {
      "name": "cgesv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为一般单精度复矩阵，并以完全格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a single precision complex general matrix and full storage",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with general matrices"
    },
    {
      "name": "zgesv",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "求解线性方程组Ax=b,其中A为一般双精度复矩阵，并以完全格式存储",
      "desc_en": "Solve a system of linear equations Ax=b where A is a double precision complex general matrix and full storage",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵线性方程组的求解性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the solution performance of linear equations with general matrices"
    },
    {
      "name": "sgetri",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据sgetrf得到的分解结果，计算逆矩阵",
      "desc_en": "Calculate the inverse matrix according to the decomposition result obtained by sgetrf",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵求逆矩阵性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates general matrix inversion matrix performance"
    },
    {
      "name": "dgetri",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据dgetrf得到的分解结果，计算逆矩阵",
      "desc_en": "Calculate the inverse matrix according to the decomposition result obtained by dgetrf",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵求逆矩阵性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates general matrix inversion matrix performance"
    },
    {
      "name": "cgetri",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据cgetrf得到的分解结果，计算逆矩阵",
      "desc_en": "Calculate the inverse matrix according to the decomposition result obtained by cgetrf",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵求逆矩阵性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates general matrix inversion matrix performance"
    },
    {
      "name": "zgetri",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据zgetrf得到的分解结果，计算逆矩阵",
      "desc_en": "Calculate the inverse matrix according to the decomposition result obtained by zgetrf",
      "benefit_cn": "基于鲲鹏框架，实现一般矩阵求逆矩阵性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates general matrix inversion matrix performance"
    },
    {
      "name": "dsyevd",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "双精度实对称矩阵的全部特征值和特征向量（可选）",
      "desc_en": "All eigenvalues and eigenvectors(optional) of double precision real symmetric matrices",
      "benefit_cn": "基于鲲鹏框架，实现对称矩阵全部特征值及特征向量性能加速",
      "benefit_en": "Basic Kunpeng architecture accelerates the performance of all eigenvalues and eigenvectors of the symmetric matrix"
    },
    {
      "name": "sorglq",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据sgelqf的计算结果，生成具有正交行的单精度实矩阵Q，即该矩阵是K个N阶基本变换矩阵的乘积的前M行",
      "desc_en": "Single precision real matrix Q with orthogonal rows is generated according to the result obtained by sgelqf,and the matrix is defined as the first M rows of the product of K elementary reflectors of order N",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "dorglq",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据dgelqf的计算结果，生成具有正交行的双精度实矩阵Q，即该矩阵是K个N阶基本变换矩阵的乘积的前M行",
      "desc_en": "Double precision real matrix Q with orthogonal rows is generated according to the result obtained by dgelqf,and the matrix is defined as the first M rows of the product of K elementary reflectors of order N",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "cunglq",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据cgelqf的计算结果，生成具有正交行的单精度复矩阵Q，即该矩阵是K个N阶基本变换矩阵的乘积的前M行",
      "desc_en": "Single precision complex matrix Q with orthogonal rows is generated according to the result obtained by cgelqf,and the matrix is defined as the first M rows of the product of K elementary reflectors of order N",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "zunglq",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据zgelqf的计算结果，生成具有正交行的双精度复矩阵Q，即该矩阵是K个N阶基本变换矩阵的乘积的前M行",
      "desc_en": "Double precision complex matrix Q with orthogonal rows is generated according to the result obtained by zgelqf,and the matrix is defined as the first M rows of the product of K elementary reflectors of order N",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "sorgqr",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据sgeqrf的计算结果，生成具有正交行的单精度实矩阵Q，即该矩阵是K个M阶基本变换矩阵的乘积的前N行",
      "desc_en": "Single precision real matrix Q with orthogonal rows is generated according to the result obtained by sgeqrf,and the matrix is defined as the first N rows of the product of K elementary reflectors of order M",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "dorgqr",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据dgeqrf的计算结果，生成具有正交行的单精度实矩阵Q，即该矩阵是K个M阶基本变换矩阵的乘积的前N行",
      "desc_en": "Double precision real matrix Q with orthogonal rows is generated according to the result obtained by sgeqrf,and the matrix is defined as the first N rows of the product of K elementary reflectors of order M",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "cungqr",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据cgeqrf的计算结果，生成具有正交行的单精度实矩阵Q，即该矩阵是K个M阶基本变换矩阵的乘积的前N行",
      "desc_en": "Single precision complex matrix Q with orthogonal rows is generated according to the result obtained by sgeqrf,and the matrix is defined as the first N rows of the product of K elementary reflectors of order M",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    },
    {
      "name": "zungqr",
      "library": "KML_LAPACK",
      "headerfile": "",
      "desc_cn": "根据zgeqrf的计算结果，生成具有正交行的单精度实矩阵Q，即该矩阵是K个M阶基本变换矩阵的乘积的前N行",
      "desc_en": "Double precision complex matrix Q with orthogonal rows is generated according to the result obtained by sgeqrf,and the matrix is defined as the first N rows of the product of K elementary reflectors of order M",
      "benefit_cn": "基于鲲鹏框架，实现生成正交矩阵Q性能加速",
      "benefit_en": "Basic Kunpeng architecture for performance acceleration with quadrature matrix Q"
    }
  ],
  "Intrinsic": [
    {
      "name": "vadd_s8",
      "full name": "int8x8_t vadd_s8(int8x8_t __a, int8x8_t __b)",
      "Intel name": "_mm_add_pi8",
      "Intel ASM": "paddb",
      "Arm ASM": "add",
      "function_en": "[vector] add [8]",
      "function_cn": "[向量]加[8]"
    },
    {
      "name": "vaddq_s8",
      "full name": "int8x16_t vaddq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "_mm_add_epi8",
      "Intel Asm": "paddw",
      "Arm Asm": "add",
      "function_en": "[vector] add [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vadd_s16",
      "full name": "int16x4_t vadd_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "_mm_add_pi16",
      "Intel Asm": "paddw",
      "Arm Asm": "add",
      "function_en": "[vector] add [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddq_s16",
      "full name": "int16x8_t vaddq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "_mm_add_epi16",
      "Intel Asm": "paddw",
      "Arm Asm": "add",
      "function_en": "[vector] add [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vadd_s32",
      "full name": "int32x2_t vadd_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "_mm_add_pi32",
      "Intel Asm": "paddd",
      "Arm Asm": "add",
      "function_en": "[vector] add [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddq_s32",
      "full name": "int32x4_t vaddq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "_mm_add_epi32",
      "Intel Asm": "paddd",
      "Arm Asm": "add",
      "function_en": "[vector] add [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vadd_s64",
      "full name": "int64x1_t vadd_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [64]",
      "function_cn": "[向量] 加 [64]"
    },
    {
      "name": "vaddq_s64",
      "full name": "int64x2_t vaddq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "_mm_add_epi64",
      "Intel Asm": "paddq",
      "Arm Asm": "add",
      "function_en": "[vector] add [64]",
      "function_cn": "[向量] 加 [64]"
    },
    {
      "name": "vadd_u8",
      "full name": "uint8x8_t vadd_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddq_u8",
      "full name": "uint8x16_t vaddq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vadd_u16",
      "full name": "uint16x4_t vadd_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddq_u16",
      "full name": "uint16x8_t vaddq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vadd_u32",
      "full name": "uint32x2_t vadd_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddq_u32",
      "full name": "uint32x4_t vaddq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vadd_u64",
      "full name": "uint64x1_t vadd_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [64]",
      "function_cn": "[向量] 加 [64]"
    },
    {
      "name": "vaddq_u64",
      "full name": "uint64x2_t vaddq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[vector] add [64]",
      "function_cn": "[向量] 加 [64]"
    },
    {
      "name": "vadd_f32",
      "full name": "float32x2_t vadd_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fadd",
      "function_en": "[vector] add [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddq_f32",
      "full name": "float32x4_t vaddq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "_mm_add_ps",
      "Intel Asm": "addps",
      "Arm Asm": "fadd",
      "function_en": "[vector] add [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vadd_f64",
      "full name": "float64x1_t vadd_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fadd",
      "function_en": "[vector] add [64]",
      "function_cn": "[向量] 加 [64]"
    },
    {
      "name": "vaddq_f64",
      "full name": "float64x2_t vaddq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "_mm_add_pd",
      "Intel Asm": "addpd",
      "Arm Asm": "fadd",
      "function_en": "[vector] add [64]",
      "function_cn": "[向量] 加 [64]"
    },
    {
      "name": "vaddd_s64",
      "full name": "int64_t vaddd_s64(int64_t a, int64_t b)",
      "Intel name": "_mm_add_si64",
      "Intel Asm": "paddq",
      "Arm Asm": "add",
      "function_en": "[scalar] add [64]",
      "function_cn": "[标量] 加 [64]"
    },
    {
      "name": "vaddd_u64",
      "full name": "uint64_t vaddd_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "add",
      "function_en": "[scalar] add [64]",
      "function_cn": "[标量] 加 [64]"
    },
    {
      "name": "vqadd_s8",
      "full name": "int8x8_t vqadd_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "_mm_adds_pi8",
      "Intel Asm": "paddsb",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vqaddq_s8",
      "full name": "int8x16_t vqaddq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "_mm_adds_epi8",
      "Intel Asm": "paddsb",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vqadd_s16",
      "full name": "int16x4_t vqadd_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "_mm_adds_pi16",
      "Intel Asm": "paddsw",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vqaddq_s16",
      "full name": "int16x8_t vqaddq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "_mm_adds_epi16",
      "Intel Asm": "paddsw",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vqadd_s32",
      "full name": "int32x2_t vqadd_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vqaddq_s32",
      "full name": "int32x4_t vqaddq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vqadd_s64",
      "full name": "int64x1_t vqadd_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vqaddq_s64",
      "full name": "int64x2_t vqaddq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[vector] sqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vqadd_u8",
      "full name": "uint8x8_t vqadd_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "_mm_adds_pu8",
      "Intel Asm": "paddusb",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vqaddq_u8",
      "full name": "uint8x16_t vqaddq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "_mm_adds_epu8",
      "Intel Asm": "paddusb",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vqadd_u16",
      "full name": "uint16x4_t vqadd_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "_mm_adds_pu16",
      "Intel Asm": "paddusw",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vqaddq_u16",
      "full name": "uint16x8_t vqaddq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "_mm_adds_epu16",
      "Intel Asm": "paddusw",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vqadd_u32",
      "full name": "uint32x2_t vqadd_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vqaddq_u32",
      "full name": "uint32x4_t vqaddq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vqadd_u64",
      "full name": "uint64x1_t vqadd_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vqaddq_u64",
      "full name": "uint64x2_t vqaddq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[vector] uqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vqaddb_s8",
      "full name": "int8_t vqaddb_s8(int8_t a, int8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[scalar] sqadd [8]",
      "function_cn": "[标量] 饱和加 [8]"
    },
    {
      "name": "vqaddh_s16",
      "full name": "int16_t vqaddh_s16(int16_t a, int16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[scalar] sqadd [16]",
      "function_cn": "[标量] 饱和加 [16]"
    },
    {
      "name": "vqadds_s32",
      "full name": "int32_t vqadds_s32(int32_t a, int32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[scalar] sqadd [32]",
      "function_cn": "[标量] 饱和加 [32]"
    },
    {
      "name": "vqaddd_s64",
      "full name": "int64_t vqaddd_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sqadd",
      "function_en": "[scalar] sqadd [64]",
      "function_cn": "[标量] 饱和加 [64]"
    },
    {
      "name": "vqaddb_u8",
      "full name": "uint8_t vqaddb_u8(uint8_t a, uint8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[scalar] uqadd [8]",
      "function_cn": "[标量] 饱和加 [8]"
    },
    {
      "name": "vqaddh_u16",
      "full name": "uint16_t vqaddh_u16(uint16_t a, uint16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[scalar] uqadd [16]",
      "function_cn": "[标量] 饱和加 [16]"
    },
    {
      "name": "vqadds_u32",
      "full name": "uint32_t vqadds_u32(uint32_t a, uint32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[scalar] uqadd [32]",
      "function_cn": "[标量] 饱和加 [32]"
    },
    {
      "name": "vqaddd_u64",
      "full name": "uint64_t vqaddd_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uqadd",
      "function_en": "[scalar] uqadd [64]",
      "function_cn": "[标量] 饱和加 [64]"
    },
    {
      "name": "vuqadd_s8",
      "full name": "int8x8_t vuqadd_s8(int8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vuqaddq_s8",
      "full name": "int8x16_t vuqaddq_s8(int8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vuqadd_s16",
      "full name": "int16x4_t vuqadd_s16(int16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vuqaddq_s16",
      "full name": "int16x8_t vuqaddq_s16(int16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vuqadd_s32",
      "full name": "int32x2_t vuqadd_s32(int32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vuqaddq_s32",
      "full name": "int32x4_t vuqaddq_s32(int32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vuqadd_s64",
      "full name": "int64x1_t vuqadd_s64(int64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vuqaddq_s64",
      "full name": "int64x2_t vuqaddq_s64(int64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[vector] suqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vuqaddb_s8",
      "full name": "int8_t vuqaddb_s8(int8_t a, uint8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[scalar] suqadd [8]",
      "function_cn": "[标量] 饱和加 [8]"
    },
    {
      "name": "vuqaddh_s16",
      "full name": "int16_t vuqaddh_s16(int16_t a, uint16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[scalar] suqadd [16]",
      "function_cn": "[标量] 饱和加 [16]"
    },
    {
      "name": "vuqadds_s32",
      "full name": "int32_t vuqadds_s32(int32_t a, uint32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[scalar] suqadd [32]",
      "function_cn": "[标量] 饱和加 [32]"
    },
    {
      "name": "vuqaddd_s64",
      "full name": "int64_t vuqaddd_s64(int64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "suqadd",
      "function_en": "[scalar] suqadd [64]",
      "function_cn": "[标量] 饱和加 [64]"
    },
    {
      "name": "vsqadd_u8",
      "full name": "uint8x8_t vsqadd_u8(uint8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vsqaddq_u8",
      "full name": "uint8x16_t vsqaddq_u8(uint8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [8]",
      "function_cn": "[向量] 饱和加 [8]"
    },
    {
      "name": "vsqadd_u16",
      "full name": "uint16x4_t vsqadd_u16(uint16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vsqaddq_u16",
      "full name": "uint16x8_t vsqaddq_u16(uint16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [16]",
      "function_cn": "[向量] 饱和加 [16]"
    },
    {
      "name": "vsqadd_u32",
      "full name": "uint32x2_t vsqadd_u32(uint32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vsqaddq_u32",
      "full name": "uint32x4_t vsqaddq_u32(uint32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [32]",
      "function_cn": "[向量] 饱和加 [32]"
    },
    {
      "name": "vsqadd_u64",
      "full name": "uint64x1_t vsqadd_u64(uint64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vsqaddq_u64",
      "full name": "uint64x2_t vsqaddq_u64(uint64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[vector] usqadd [64]",
      "function_cn": "[向量] 饱和加 [64]"
    },
    {
      "name": "vsqaddb_u8",
      "full name": "uint8_t vsqaddb_u8(uint8_t a, int8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[scalar] usqadd [8]",
      "function_cn": "[标量] 饱和加 [8]"
    },
    {
      "name": "vsqaddh_u16",
      "full name": "uint16_t vsqaddh_u16(uint16_t a, int16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[scalar] usqadd [16]",
      "function_cn": "[标量] 饱和加 [16]"
    },
    {
      "name": "vsqadds_u32",
      "full name": "uint32_t vsqadds_u32(uint32_t a, int32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[scalar] usqadd [32]",
      "function_cn": "[标量] 饱和加 [32]"
    },
    {
      "name": "vsqaddd_u64",
      "full name": "uint64_t vsqaddd_u64(uint64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "usqadd",
      "function_en": "[scalar] usqadd [64]",
      "function_cn": "[标量] 饱和加 [64]"
    },
    {
      "name": "vaddhn_s16",
      "full name": "int8x8_t vaddhn_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn",
      "function_en": "[vector] addhn [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vaddhn_s32",
      "full name": "int16x4_t vaddhn_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn",
      "function_en": "[vector] addhn [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vaddhn_s64",
      "full name": "int32x2_t vaddhn_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn",
      "function_en": "[vector] addhn [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vaddhn_u16",
      "full name": "uint8x8_t vaddhn_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn",
      "function_en": "[vector] addhn [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vaddhn_u32",
      "full name": "uint16x4_t vaddhn_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn",
      "function_en": "[vector] addhn [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vaddhn_u64",
      "full name": "uint32x2_t vaddhn_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn",
      "function_en": "[vector] addhn [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vaddhn_high_s16",
      "full name": "int8x16_t vaddhn_high_s16(int8x8_t r, int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn2",
      "function_en": "[vector] addhn2 [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vaddhn_high_s32",
      "full name": "int16x8_t vaddhn_high_s32(int16x4_t r, int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn2",
      "function_en": "[vector] addhn2 [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vaddhn_high_s64",
      "full name": "int32x4_t vaddhn_high_s64(int32x2_t r, int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn2",
      "function_en": "[vector] addhn2 [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vaddhn_high_u16",
      "full name": "uint8x16_t vaddhn_high_u16(uint8x8_t r, uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn2",
      "function_en": "[vector] addhn2 [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vaddhn_high_u32",
      "full name": "uint16x8_t vaddhn_high_u32(uint16x4_t r, uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn2",
      "function_en": "[vector] addhn2 [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vaddhn_high_u64",
      "full name": "uint32x4_t vaddhn_high_u64(uint32x2_t r, uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "addhn2",
      "function_en": "[vector] addhn2 [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vraddhn_s16",
      "full name": "int8x8_t vraddhn_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn",
      "function_en": "[vector] raddhn [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vraddhn_s32",
      "full name": "int16x4_t vraddhn_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn",
      "function_en": "[vector] raddhn [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vraddhn_s64",
      "full name": "int32x2_t vraddhn_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn",
      "function_en": "[vector] raddhn [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vraddhn_u16",
      "full name": "uint8x8_t vraddhn_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn",
      "function_en": "[vector] raddhn [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vraddhn_u32",
      "full name": "uint16x4_t vraddhn_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn",
      "function_en": "[vector] raddhn [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vraddhn_u64",
      "full name": "uint32x2_t vraddhn_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn",
      "function_en": "[vector] raddhn [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vraddhn_high_s16",
      "full name": "int8x16_t vraddhn_high_s16(int8x8_t r, int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn2",
      "function_en": "[vector] raddhn2 [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vraddhn_high_s32",
      "full name": "int16x8_t vraddhn_high_s32(int16x4_t r, int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn2",
      "function_en": "[vector] raddhn2 [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vraddhn_high_s64",
      "full name": "int32x4_t vraddhn_high_s64(int32x2_t r, int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn2",
      "function_en": "[vector] raddhn2 [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vraddhn_high_u16",
      "full name": "uint8x16_t vraddhn_high_u16(uint8x8_t r, uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn2",
      "function_en": "[vector] raddhn2 [16]",
      "function_cn": "[向量] 窄型加 [16]"
    },
    {
      "name": "vraddhn_high_u32",
      "full name": "uint16x8_t vraddhn_high_u32(uint16x4_t r, uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn2",
      "function_en": "[vector] raddhn2 [32]",
      "function_cn": "[向量] 窄型加 [32]"
    },
    {
      "name": "vraddhn_high_u64",
      "full name": "uint32x4_t vraddhn_high_u64(uint32x2_t r, uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "raddhn2",
      "function_en": "[vector] raddhn2 [64]",
      "function_cn": "[向量] 窄型加 [64]"
    },
    {
      "name": "vaddl_s8",
      "full name": "int16x8_t vaddl_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddl",
      "function_en": "[vector] saddl [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddl_s16",
      "full name": "int32x4_t vaddl_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddl",
      "function_en": "[vector] saddl [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddl_s32",
      "full name": "int64x2_t vaddl_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddl",
      "function_en": "[vector] saddl [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddl_u8",
      "full name": "uint16x8_t vaddl_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddl",
      "function_en": "[vector] uaddl [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddl_u16",
      "full name": "uint32x4_t vaddl_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddl",
      "function_en": "[vector] uaddl [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddl_u32",
      "full name": "uint64x2_t vaddl_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddl",
      "function_en": "[vector] uaddl [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddl_high_s8",
      "full name": "int16x8_t vaddl_high_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddl2",
      "function_en": "[vector] saddl2 [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddl_high_s16",
      "full name": "int32x4_t vaddl_high_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddl2",
      "function_en": "[vector] saddl2 [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddl_high_s32",
      "full name": "int64x2_t vaddl_high_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddl2",
      "function_en": "[vector] saddl2 [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddl_high_u8",
      "full name": "uint16x8_t vaddl_high_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddl2",
      "function_en": "[vector] uaddl2 [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddl_high_u16",
      "full name": "uint32x4_t vaddl_high_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddl2",
      "function_en": "[vector] uaddl2 [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddl_high_u32",
      "full name": "uint64x2_t vaddl_high_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddl2",
      "function_en": "[vector] uaddl2 [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddw_s8",
      "full name": "int16x8_t vaddw_s8(int16x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddw",
      "function_en": "[vector] saddw [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddw_s16",
      "full name": "int32x4_t vaddw_s16(int32x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddw",
      "function_en": "[vector] saddw [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddw_s32",
      "full name": "int64x2_t vaddw_s32(int64x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddw",
      "function_en": "[vector] saddw [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddw_u8",
      "full name": "uint16x8_t vaddw_u8(uint16x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddw",
      "function_en": "[vector] uaddw [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddw_u16",
      "full name": "uint32x4_t vaddw_u16(uint32x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddw",
      "function_en": "[vector] uaddw [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddw_u32",
      "full name": "uint64x2_t vaddw_u32(uint64x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddw",
      "function_en": "[vector] uaddw [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddw_high_s8",
      "full name": "int16x8_t vaddw_high_s8(int16x8_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddw2",
      "function_en": "[vector] saddw2 [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddw_high_s16",
      "full name": "int32x4_t vaddw_high_s16(int32x4_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddw2",
      "function_en": "[vector] saddw2 [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddw_high_s32",
      "full name": "int64x2_t vaddw_high_s32(int64x2_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saddw2",
      "function_en": "[vector] saddw2 [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vaddw_high_u8",
      "full name": "uint16x8_t vaddw_high_u8(uint16x8_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddw2",
      "function_en": "[vector] uaddw2 [8]",
      "function_cn": "[向量] 加 [8]"
    },
    {
      "name": "vaddw_high_u16",
      "full name": "uint32x4_t vaddw_high_u16(uint32x4_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddw2",
      "function_en": "[vector] uaddw2 [16]",
      "function_cn": "[向量] 加 [16]"
    },
    {
      "name": "vaddw_high_u32",
      "full name": "uint64x2_t vaddw_high_u32(uint64x2_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaddw2",
      "function_en": "[vector] uaddw2 [32]",
      "function_cn": "[向量] 加 [32]"
    },
    {
      "name": "vhadd_s8",
      "full name": "int8x8_t vhadd_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "shadd",
      "function_en": "[vector] shadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vhaddq_s8",
      "full name": "int8x16_t vhaddq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "shadd",
      "function_en": "[vector] shadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vhadd_s16",
      "full name": "int16x4_t vhadd_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "shadd",
      "function_en": "[vector] shadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vhaddq_s16",
      "full name": "int16x8_t vhaddq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "shadd",
      "function_en": "[vector] shadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vhadd_s32",
      "full name": "int32x2_t vhadd_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "shadd",
      "function_en": "[vector] shadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vhaddq_s32",
      "full name": "int32x4_t vhaddq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "shadd",
      "function_en": "[vector] shadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vhadd_u8",
      "full name": "uint8x8_t vhadd_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uhadd",
      "function_en": "[vector] uhadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vhaddq_u8",
      "full name": "uint8x16_t vhaddq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uhadd",
      "function_en": "[vector] uhadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vhadd_u16",
      "full name": "uint16x4_t vhadd_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uhadd",
      "function_en": "[vector] uhadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vhaddq_u16",
      "full name": "uint16x8_t vhaddq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uhadd",
      "function_en": "[vector] uhadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vhadd_u32",
      "full name": "uint32x2_t vhadd_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uhadd",
      "function_en": "[vector] uhadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vhaddq_u32",
      "full name": "uint32x4_t vhaddq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uhadd",
      "function_en": "[vector] uhadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vrhadd_s8",
      "full name": "int8x8_t vrhadd_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "srhadd",
      "function_en": "[vector] srhadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vrhaddq_s8",
      "full name": "int8x16_t vrhaddq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "srhadd",
      "function_en": "[vector] srhadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vrhadd_s16",
      "full name": "int16x4_t vrhadd_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "srhadd",
      "function_en": "[vector] srhadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vrhaddq_s16",
      "full name": "int16x8_t vrhaddq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "srhadd",
      "function_en": "[vector] srhadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vrhadd_s32",
      "full name": "int32x2_t vrhadd_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "srhadd",
      "function_en": "[vector] srhadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vrhaddq_s32",
      "full name": "int32x4_t vrhaddq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "srhadd",
      "function_en": "[vector] srhadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vrhadd_u8",
      "full name": "uint8x8_t vrhadd_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "_mm_avg_pu8",
      "Intel Asm": "pavgb",
      "Arm Asm": "urhadd",
      "function_en": "[vector] urhadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vrhaddq_u8",
      "full name": "uint8x16_t vrhaddq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "_mm_avg_epu8",
      "Intel Asm": "pavgb",
      "Arm Asm": "urhadd",
      "function_en": "[vector] urhadd [8]",
      "function_cn": "[向量] 相加并右移一位 [8]"
    },
    {
      "name": "vrhadd_u16",
      "full name": "uint16x4_t vrhadd_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "_mm_avg_pu16",
      "Intel Asm": "pavgw",
      "Arm Asm": "urhadd",
      "function_en": "[vector] urhadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vrhaddq_u16",
      "full name": "uint16x8_t vrhaddq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "_mm_avg_epu16",
      "Intel Asm": "pavgw",
      "Arm Asm": "urhadd",
      "function_en": "[vector] urhadd [16]",
      "function_cn": "[向量] 相加并右移一位 [16]"
    },
    {
      "name": "vrhadd_u32",
      "full name": "uint32x2_t vrhadd_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "urhadd",
      "function_en": "[vector] urhadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
    {
      "name": "vrhaddq_u32",
      "full name": "uint32x4_t vrhaddq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "urhadd",
      "function_en": "[vector] urhadd [32]",
      "function_cn": "[向量] 相加并右移一位 [32]"
    },
	{
	  "name": "vmul_s8",
	  "full name": "int8x8_t vmul_s8(int8x8_t a, int8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [8]",
	  "function_cn": "[向量] 乘 [8]"
	},
	{
	  "name": "vmulq_s8",
	  "full name": "int8x16_t vmulq_s8(int8x16_t a, int8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [8]",
	  "function_cn": "[向量] 乘 [8]"
	},
	{
	  "name": "vmul_s16",
	  "full name": "int16x4_t vmul_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "_mm_mullo_pi16",
	  "Intel Asm": "pmullw",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [16]",
	  "function_cn": "[向量] 乘 [16]"
	},
	{
	  "name": "vmulq_s16",
	  "full name": "int16x8_t vmulq_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "_mm_mullo_epi16",
	  "Intel Asm": "pmullw",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [16]",
	  "function_cn": "[向量] 乘 [16]"
	},
	{
	  "name": "vmul_s32",
	  "full name": "int32x2_t vmul_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulq_s32",
	  "full name": "int32x4_t vmulq_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "_mm_mullo_epi32",
	  "Intel Asm": "pmulld",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmul_u8",
	  "full name": "uint8x8_t vmul_u8(uint8x8_t a, uint8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [8]",
	  "function_cn": "[向量] 乘 [8]"
	},
	{
	  "name": "vmulq_u8",
	  "full name": "uint8x16_t vmulq_u8(uint8x16_t a, uint8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [8]",
	  "function_cn": "[向量] 乘 [8]"
	},
	{
	  "name": "vmul_u16",
	  "full name": "uint16x4_t vmul_u16(uint16x4_t a, uint16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [16]",
	  "function_cn": "[向量] 乘 [16]"
	},
	{
	  "name": "vmulq_u16",
	  "full name": "uint16x8_t vmulq_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [16]",
	  "function_cn": "[向量] 乘 [16]"
	},
	{
	  "name": "vmul_u32",
	  "full name": "uint32x2_t vmul_u32(uint32x2_t a, uint32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulq_u32",
	  "full name": "uint32x4_t vmulq_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mul",
	  "function_en": "[vector] mul [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmul_f32",
	  "full name": "float32x2_t vmul_f32(float32x2_t a, float32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmul",
	  "function_en": "[vector] fmul [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulq_f32",
	  "full name": "float32x4_t vmulq_f32(float32x4_t a, float32x4_t b)",
	  "Intel name": "_mm_mul_ps",
	  "Intel Asm": "mulps",
	  "Arm Asm": "fmul",
	  "function_en": "[vector] fmul [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmul_p8",
	  "full name": "poly8x8_t vmul_p8(poly8x8_t a, poly8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "pmul",
	  "function_en": "[vector] pmul [8]",
	  "function_cn": "[向量] 多项式乘 [8]"
	},
	{
	  "name": "vmulq_p8",
	  "full name": "poly8x16_t vmulq_p8(poly8x16_t a, poly8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "pmul",
	  "function_en": "[vector] pmul [8]",
	  "function_cn": "[向量] 多项式乘 [8]"
	},
	{
	  "name": "vmul_f64",
	  "full name": "float64x1_t vmul_f64(float64x1_t a, float64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmul",
	  "function_en": "[vector] fmul [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulq_f64",
	  "full name": "float64x2_t vmulq_f64(float64x2_t a, float64x2_t b)",
	  "Intel name": "_mm_mul_pd",
	  "Intel Asm": "mulpd",
	  "Arm Asm": "fmul",
	  "function_en": "[vector] fmul [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulx_f32",
	  "full name": "float32x2_t vmulx_f32(float32x2_t a, float32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulxq_f32",
	  "full name": "float32x4_t vmulxq_f32(float32x4_t a, float32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulx_f64",
	  "full name": "float64x1_t vmulx_f64(float64x1_t a, float64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulxq_f64",
	  "full name": "float64x2_t vmulxq_f64(float64x2_t a, float64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulxs_f32",
	  "full name": "float32_t vmulxs_f32(float32_t a, float32_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulxd_f64",
	  "full name": "float64_t vmulxd_f64(float64_t a, float64_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulx_lane_f32",
	  "full name": "float32x2_t vmulx_lane_f32(float32x2_t a, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulxq_lane_f32",
	  "full name": "float32x4_t vmulxq_lane_f32(float32x4_t a, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulx_lane_f64",
	  "full name": "float64x1_t vmulx_lane_f64(float64x1_t a, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulxq_lane_f64",
	  "full name": "float64x2_t vmulxq_lane_f64(float64x2_t a, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulxs_lane_f32",
	  "full name": "float32_t vmulxs_lane_f32(float32_t a, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulxd_lane_f64",
	  "full name": "float64_t vmulxd_lane_f64(float64_t a, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulx_laneq_f32",
	  "full name": "float32x2_t vmulx_laneq_f32(float32x2_t a, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulxq_laneq_f32",
	  "full name": "float32x4_t vmulxq_laneq_f32(float32x4_t a, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulx_laneq_f64",
	  "full name": "float64x1_t vmulx_laneq_f64(float64x1_t a, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulxq_laneq_f64",
	  "full name": "float64x2_t vmulxq_laneq_f64(float64x2_t a, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vmulxs_laneq_f32",
	  "full name": "float32_t vmulxs_laneq_f32(float32_t a, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [32]",
	  "function_cn": "[向量] 乘 [32]"
	},
	{
	  "name": "vmulxd_laneq_f64",
	  "full name": "float64_t vmulxd_laneq_f64(float64_t a, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmulx",
	  "function_en": "[vector] fmulx [64]",
	  "function_cn": "[向量] 乘 [64]"
	},
	{
	  "name": "vdiv_f32",
	  "full name": "float32x2_t vdiv_f32(float32x2_t a, float32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fdiv",
	  "function_en": "[vector] fdiv [32]",
	  "function_cn": "[向量] 除 [32]"
	},
	{
	  "name": "vdivq_f32",
	  "full name": "float32x4_t vdivq_f32(float32x4_t a, float32x4_t b)",
	  "Intel name": "_mm_div_ps",
	  "Intel Asm": "divps",
	  "Arm Asm": "fdiv",
	  "function_en": "[vector] fdiv [32]",
	  "function_cn": "[向量] 除 [32]"
	},
	{
	  "name": "vdiv_f64",
	  "full name": "float64x1_t vdiv_f64(float64x1_t a, float64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fdiv",
	  "function_en": "[vector] fdiv [64]",
	  "function_cn": "[向量] 除 [64]"
	},
	{
	  "name": "vdivq_f64",
	  "full name": "float64x2_t vdivq_f64(float64x2_t a, float64x2_t b)",
	  "Intel name": "_mm_div_pd",
	  "Intel Asm": "divpd",
	  "Arm Asm": "fdiv",
	  "function_en": "[vector] fdiv [64]",
	  "function_cn": "[向量] 除 [64]"
	},
	{
	  "name": "vmla_s8",
	  "full name": "int8x8_t vmla_s8(int8x8_t a, int8x8_t b, int8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmlaq_s8",
	  "full name": "int8x16_t vmlaq_s8(int8x16_t a, int8x16_t b, int8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmla_s16",
	  "full name": "int16x4_t vmla_s16(int16x4_t a, int16x4_t b, int16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmlaq_s16",
	  "full name": "int16x8_t vmlaq_s16(int16x8_t a, int16x8_t b, int16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmla_s32",
	  "full name": "int32x2_t vmla_s32(int32x2_t a, int32x2_t b, int32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmlaq_s32",
	  "full name": "int32x4_t vmlaq_s32(int32x4_t a, int32x4_t b, int32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmla_u8",
	  "full name": "uint8x8_t vmla_u8(uint8x8_t a, uint8x8_t b, uint8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmlaq_u8",
	  "full name": "uint8x16_t vmlaq_u8(uint8x16_t a, uint8x16_t b, uint8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmla_u16",
	  "full name": "uint16x4_t vmla_u16(uint16x4_t a, uint16x4_t b, uint16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmlaq_u16",
	  "full name": "uint16x8_t vmlaq_u16(uint16x8_t a, uint16x8_t b, uint16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmla_u32",
	  "full name": "uint32x2_t vmla_u32(uint32x2_t a, uint32x2_t b, uint32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmlaq_u32",
	  "full name": "uint32x4_t vmlaq_u32(uint32x4_t a, uint32x4_t b, uint32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mla",
	  "function_en": "[vector] mla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmla_f32",
	  "full name": "float32x2_t vmla_f32(float32x2_t a, float32x2_t b, float32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "",
	  "function_en": "[vector] flma [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmlaq_f32",
	  "full name": "float32x4_t vmlaq_f32(float32x4_t a, float32x4_t b, float32x4_t c)",
	  "Intel name": "_mm_fmadd_ps",
	  "Intel Asm": "vfmadd132ps",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmla_f64",
	  "full name": "float64x1_t vmla_f64(float64x1_t a, float64x1_t b, float64x1_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vmlaq_f64",
	  "full name": "float64x2_t vmlaq_f64(float64x2_t a, float64x2_t b, float64x2_t c)",
	  "Intel name": "_mm_fmadd_pd",
	  "Intel Asm": "vfmadd132pd",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vmlal_s8",
	  "full name": "int16x8_t vmlal_s8(int16x8_t a, int8x8_t b, int8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlal",
	  "function_en": "[vector] smlal [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmlal_s16",
	  "full name": "int32x4_t vmlal_s16(int32x4_t a, int16x4_t b, int16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlal",
	  "function_en": "[vector] smlal [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmlal_s32",
	  "full name": "int64x2_t vmlal_s32(int64x2_t a, int32x2_t b, int32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlal",
	  "function_en": "[vector] smlal [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmlal_u8",
	  "full name": "uint16x8_t vmlal_u8(uint16x8_t a, uint8x8_t b, uint8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlal",
	  "function_en": "[vector] umlal [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmlal_u16",
	  "full name": "uint32x4_t vmlal_u16(uint32x4_t a, uint16x4_t b, uint16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlal",
	  "function_en": "[vector] umlal [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmlal_u32",
	  "full name": "uint64x2_t vmlal_u32(uint64x2_t a, uint32x2_t b, uint32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlal",
	  "function_en": "[vector] umlal [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmlal_high_s8",
	  "full name": "int16x8_t vmlal_high_s8(int16x8_t a, int8x16_t b, int8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlal2",
	  "function_en": "[vector] smlal2 [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmlal_high_s16",
	  "full name": "int32x4_t vmlal_high_s16(int32x4_t a, int16x8_t b, int16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlal2",
	  "function_en": "[vector] smlal2 [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmlal_high_s32",
	  "full name": "int64x2_t vmlal_high_s32(int64x2_t a, int32x4_t b, int32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlal2",
	  "function_en": "[vector] smlal2 [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vmlal_high_u8",
	  "full name": "uint16x8_t vmlal_high_u8(uint16x8_t a, uint8x16_t b, uint8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlal2",
	  "function_en": "[vector] umlal2 [8]",
	  "function_cn": "[向量] 乘加 [8]"
	},
	{
	  "name": "vmlal_high_u16",
	  "full name": "uint32x4_t vmlal_high_u16(uint32x4_t a, uint16x8_t b, uint16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlal2",
	  "function_en": "[vector] umlal2 [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmlal_high_u32",
	  "full name": "uint64x2_t vmlal_high_u32(uint64x2_t a, uint32x4_t b, uint32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlal2",
	  "function_en": "[vector] umlal2 [16]",
	  "function_cn": "[向量] 乘加 [16]"
	},
	{
	  "name": "vmls_s8",
	  "full name": "int8x8_t vmls_s8(int8x8_t a, int8x8_t b, int8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmlsq_s8",
	  "full name": "int8x16_t vmlsq_s8(int8x16_t a, int8x16_t b, int8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmls_s16",
	  "full name": "int16x4_t vmls_s16(int16x4_t a, int16x4_t b, int16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmlsq_s16",
	  "full name": "int16x8_t vmlsq_s16(int16x8_t a, int16x8_t b, int16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmls_s32",
	  "full name": "int32x2_t vmls_s32(int32x2_t a, int32x2_t b, int32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmlsq_s32",
	  "full name": "int32x4_t vmlsq_s32(int32x4_t a, int32x4_t b, int32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmls_u8",
	  "full name": "uint8x8_t vmls_u8(uint8x8_t a, uint8x8_t b, uint8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmlsq_u8",
	  "full name": "uint8x16_t vmlsq_u8(uint8x16_t a, uint8x16_t b, uint8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmls_u16",
	  "full name": "uint16x4_t vmls_u16(uint16x4_t a, uint16x4_t b, uint16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmlsq_u16",
	  "full name": "uint16x8_t vmlsq_u16(uint16x8_t a, uint16x8_t b, uint16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmls_u32",
	  "full name": "uint32x2_t vmls_u32(uint32x2_t a, uint32x2_t b, uint32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmlsq_u32",
	  "full name": "uint32x4_t vmlsq_u32(uint32x4_t a, uint32x4_t b, uint32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "mls",
	  "function_en": "[vector] mls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmls_f32",
	  "full name": "float32x2_t vmls_f32(float32x2_t a, float32x2_t b, float32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmlsq_f32",
	  "full name": "float32x4_t vmlsq_f32(float32x4_t a, float32x4_t b, float32x4_t c)",
	  "Intel name": "_mm_fmsub_ps",
	  "Intel Asm": "vfmsub132ps",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmls_f64",
	  "full name": "float64x1_t vmls_f64(float64x1_t a, float64x1_t b, float64x1_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vmlsq_f64",
	  "full name": "float64x2_t vmlsq_f64(float64x2_t a, float64x2_t b, float64x2_t c)",
	  "Intel name": "_mm_fmsub_pd",
	  "Intel Asm": "vfmsub132pd",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vmlsl_s8",
	  "full name": "int16x8_t vmlsl_s8(int16x8_t a, int8x8_t b, int8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlsl",
	  "function_en": "[vector] smlsl [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmlsl_s16",
	  "full name": "int32x4_t vmlsl_s16(int32x4_t a, int16x4_t b, int16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlsl",
	  "function_en": "[vector] smlsl [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmlsl_s32",
	  "full name": "int64x2_t vmlsl_s32(int64x2_t a, int32x2_t b, int32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlsl",
	  "function_en": "[vector] smlsl [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmlsl_u8",
	  "full name": "uint16x8_t vmlsl_u8(uint16x8_t a, uint8x8_t b, uint8x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlsl",
	  "function_en": "[vector] umlsl [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmlsl_u16",
	  "full name": "uint32x4_t vmlsl_u16(uint32x4_t a, uint16x4_t b, uint16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlsl",
	  "function_en": "[vector] umlsl [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmlsl_u32",
	  "full name": "uint64x2_t vmlsl_u32(uint64x2_t a, uint32x2_t b, uint32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlsl",
	  "function_en": "[vector] umlsl [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmlsl_high_s8",
	  "full name": "int16x8_t vmlsl_high_s8(int16x8_t a, int8x16_t b, int8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlsl2",
	  "function_en": "[vector] smlsl2 [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmlsl_high_s16",
	  "full name": "int32x4_t vmlsl_high_s16(int32x4_t a, int16x8_t b, int16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlsl2",
	  "function_en": "[vector] smlsl2 [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmlsl_high_s32",
	  "full name": "int64x2_t vmlsl_high_s32(int64x2_t a, int32x4_t b, int32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smlsl2",
	  "function_en": "[vector] smlsl2 [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vmlsl_high_u8",
	  "full name": "uint16x8_t vmlsl_high_u8(uint16x8_t a, uint8x16_t b, uint8x16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlsl2",
	  "function_en": "[vector] umlsl2 [8]",
	  "function_cn": "[向量] 乘减 [8]"
	},
	{
	  "name": "vmlsl_high_u16",
	  "full name": "uint32x4_t vmlsl_high_u16(uint32x4_t a, uint16x8_t b, uint16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlsl2",
	  "function_en": "[vector] umlsl2 [16]",
	  "function_cn": "[向量] 乘减 [16]"
	},
	{
	  "name": "vmlsl_high_u32",
	  "full name": "uint64x2_t vmlsl_high_u32(uint64x2_t a, uint32x4_t b, uint32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umlsl2",
	  "function_en": "[vector] umlsl2 [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfma_f32",
	  "full name": "float32x2_t vfma_f32(float32x2_t a, float32x2_t b, float32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfmaq_f32",
	  "full name": "float32x4_t vfmaq_f32(float32x4_t a, float32x4_t b, float32x4_t c)",
	  "Intel name": "_mm_fmadd_ps",
	  "Intel Asm": "vfmadd132ps",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfma_f64",
	  "full name": "float64x1_t vfma_f64(float64x1_t a, float64x1_t b, float64x1_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmadd",
	  "function_en": "[vector] fmadd [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfmaq_f64",
	  "full name": "float64x2_t vfmaq_f64(float64x2_t a, float64x2_t b, float64x2_t c)",
	  "Intel name": "_mm_fmadd_pd",
	  "Intel Asm": "vfmadd132pd",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfma_lane_f32",
	  "full name": "float32x2_t vfma_lane_f32(float32x2_t a, float32x2_t b, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfmaq_lane_f32",
	  "full name": "float32x4_t vfmaq_lane_f32(float32x4_t a, float32x4_t b, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfma_lane_f64",
	  "full name": "float64x1_t vfma_lane_f64(float64x1_t a, float64x1_t b, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfmaq_lane_f64",
	  "full name": "float64x2_t vfmaq_lane_f64(float64x2_t a, float64x2_t b, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfmas_lane_f32",
	  "full name": "float32_t vfmas_lane_f32(float32_t a, float32_t b, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfmad_lane_f64",
	  "full name": "float64_t vfmad_lane_f64(float64_t a, float64_t b, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfma_laneq_f32",
	  "full name": "float32x2_t vfma_laneq_f32(float32x2_t a, float32x2_t b, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfmaq_laneq_f32",
	  "full name": "float32x4_t vfmaq_laneq_f32(float32x4_t a, float32x4_t b, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfma_laneq_f64",
	  "full name": "float64x1_t vfma_laneq_f64(float64x1_t a, float64x1_t b, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfmaq_laneq_f64",
	  "full name": "float64x2_t vfmaq_laneq_f64(float64x2_t a, float64x2_t b, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfmas_laneq_f32",
	  "full name": "float32_t vfmas_laneq_f32(float32_t a, float32_t b, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [32]",
	  "function_cn": "[向量] 乘加 [32]"
	},
	{
	  "name": "vfmad_laneq_f64",
	  "full name": "float64_t vfmad_laneq_f64(float64_t a, float64_t b, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmla",
	  "function_en": "[vector] fmla [64]",
	  "function_cn": "[向量] 乘加 [64]"
	},
	{
	  "name": "vfms_f32",
	  "full name": "float32x2_t vfms_f32(float32x2_t a, float32x2_t b, float32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfmsq_f32",
	  "full name": "float32x4_t vfmsq_f32(float32x4_t a, float32x4_t b, float32x4_t c)",
	  "Intel name": "_mm_fmsub_ps",
	  "Intel Asm": "vfmsub132ps",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfms_f64",
	  "full name": "float64x1_t vfms_f64(float64x1_t a, float64x1_t b, float64x1_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmsub",
	  "function_en": "[vector] fmsub [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfmsq_f64",
	  "full name": "float64x2_t vfmsq_f64(float64x2_t a, float64x2_t b, float64x2_t c)",
	  "Intel name": "_mm_fmsub_pd",
	  "Intel Asm": "vfmsub132pd",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfms_lane_f32",
	  "full name": "float32x2_t vfms_lane_f32(float32x2_t a, float32x2_t b, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfmsq_lane_f32",
	  "full name": "float32x4_t vfmsq_lane_f32(float32x4_t a, float32x4_t b, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfms_lane_f64",
	  "full name": "float64x1_t vfms_lane_f64(float64x1_t a, float64x1_t b, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfmsq_lane_f64",
	  "full name": "float64x2_t vfmsq_lane_f64(float64x2_t a, float64x2_t b, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfmss_lane_f32",
	  "full name": "float32_t vfmss_lane_f32(float32_t a, float32_t b, float32x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfmsd_lane_f64",
	  "full name": "float64_t vfmsd_lane_f64(float64_t a, float64_t b, float64x1_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfms_laneq_f32",
	  "full name": "float32x2_t vfms_laneq_f32(float32x2_t a, float32x2_t b, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfmsq_laneq_f32",
	  "full name": "float32x4_t vfmsq_laneq_f32(float32x4_t a, float32x4_t b, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfms_laneq_f64",
	  "full name": "float64x1_t vfms_laneq_f64(float64x1_t a, float64x1_t b, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfmsq_laneq_f64",
	  "full name": "float64x2_t vfmsq_laneq_f64(float64x2_t a, float64x2_t b, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vfmss_laneq_f32",
	  "full name": "float32_t vfmss_laneq_f32(float32_t a, float32_t b, float32x4_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [32]",
	  "function_cn": "[向量] 乘减 [32]"
	},
	{
	  "name": "vfmsd_laneq_f64",
	  "full name": "float64_t vfmsd_laneq_f64(float64_t a, float64_t b, float64x2_t v, const int lane)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fmls",
	  "function_en": "[vector] fmls [64]",
	  "function_cn": "[向量] 乘减 [64]"
	},
	{
	  "name": "vqdmulh_s16",
	  "full name": "int16x4_t vqdmulh_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmulh",
	  "function_en": "[vector] sqdmulh [16]",
	  "function_cn": "[向量] 饱和加倍乘 [16]"
	},
	{
	  "name": "vqdmulhq_s16",
	  "full name": "int16x8_t vqdmulhq_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmulh",
	  "function_en": "[vector] sqdmulh [16]",
	  "function_cn": "[向量] 饱和加倍乘 [16]"
	},
	{
	  "name": "vqdmulh_s32",
	  "full name": "int32x2_t vqdmulh_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmulh",
	  "function_en": "[vector] sqdmulh [32]",
	  "function_cn": "[向量] 饱和加倍乘 [32]"
	},
	{
	  "name": "vqdmulhq_s32",
	  "full name": "int32x4_t vqdmulhq_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmulh",
	  "function_en": "[vector] sqdmulh [32]",
	  "function_cn": "[向量] 饱和加倍乘 [32]"
	},
	{
	  "name": "vqdmulhh_s16",
	  "full name": "int16_t vqdmulhh_s16(int16_t a, int16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmulh",
	  "function_en": "[scalar] sqdmulh [16]",
	  "function_cn": "[标量] 饱和加倍乘 [16]"
	},
	{
	  "name": "vqdmulhs_s32",
	  "full name": "int32_t vqdmulhs_s32(int32_t a, int32_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmulh",
	  "function_en": "[scalar] sqdmulh [32]",
	  "function_cn": "[标量] 饱和加倍乘 [32]"
	},
	{
	  "name": "vqrdmulh_s16",
	  "full name": "int16x4_t vqrdmulh_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqrdmulh",
	  "function_en": "[vector] sqrdmulh [16]",
	  "function_cn": "[向量] 饱和加倍乘 [16]"
	},
	{
	  "name": "vqrdmulhq_s16",
	  "full name": "int16x8_t vqrdmulhq_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqrdmulh",
	  "function_en": "[vector] sqrdmulh [16]",
	  "function_cn": "[向量] 饱和加倍乘 [16]"
	},
	{
	  "name": "vqrdmulh_s32",
	  "full name": "int32x2_t vqrdmulh_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqrdmulh",
	  "function_en": "[vector] sqrdmulh [32]",
	  "function_cn": "[向量] 饱和加倍乘 [32]"
	},
	{
	  "name": "vqrdmulhq_s32",
	  "full name": "int32x4_t vqrdmulhq_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqrdmulh",
	  "function_en": "[vector] sqrdmulh [32]",
	  "function_cn": "[向量] 饱和加倍乘 [32]"
	},
	{
	  "name": "vqrdmulhh_s16",
	  "full name": "int16_t vqrdmulhh_s16(int16_t a, int16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqrdmulh",
	  "function_en": "[scalar] sqrdmulh [16]",
	  "function_cn": "[标量] 饱和加倍乘 [16]"
	},
	{
	  "name": "vqrdmulhs_s32",
	  "full name": "int32_t vqrdmulhs_s32(int32_t a, int32_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqrdmulh",
	  "function_en": "[scalar] sqrdmulh [32]",
	  "function_cn": "[标量] 饱和加倍乘 [32]"
	},
	{
	  "name": "vqdmlal_s16",
	  "full name": "int32x4_t vqdmlal_s16(int32x4_t a, int16x4_t b, int16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlal",
	  "function_en": "[vector] sqdmlal [16]",
	  "function_cn": "[向量] 饱和加倍乘加 [16]"
	},
	{
	  "name": "vqdmlal_s32",
	  "full name": "int64x2_t vqdmlal_s32(int64x2_t a, int32x2_t b, int32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlal",
	  "function_en": "[vector] sqdmlal [32]",
	  "function_cn": "[向量] 饱和加倍乘加 [32]"
	},
	{
	  "name": "vqdmlalh_s16",
	  "full name": "int32_t vqdmlalh_s16(int32_t a, int16_t b, int16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlal",
	  "function_en": "[scalar] sqdmlal [16]",
	  "function_cn": "[标量] 饱和加倍乘加 [16]"
	},
	{
	  "name": "vqdmlals_s32",
	  "full name": "int64_t vqdmlals_s32(int64_t a, int32_t b, int32_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlal",
	  "function_en": "[scalar] sqdmlal [32]",
	  "function_cn": "[标量] 饱和加倍乘加 [32]"
	},
	{
	  "name": "vqdmlal_high_s16",
	  "full name": "int32x4_t vqdmlal_high_s16(int32x4_t a, int16x8_t b, int16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlal2",
	  "function_en": "[vector] sqdmlal2 [16]",
	  "function_cn": "[向量] 饱和加倍乘加 [16]"
	},
	{
	  "name": "vqdmlal_high_s32",
	  "full name": "int64x2_t vqdmlal_high_s32(int64x2_t a, int32x4_t b, int32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlal2",
	  "function_en": "[vector] sqdmlal2 [32]",
	  "function_cn": "[向量] 饱和加倍乘加 [32]"
	},
	{
	  "name": "vqdmlsl_s16",
	  "full name": "int32x4_t vqdmlsl_s16(int32x4_t a, int16x4_t b, int16x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlsl",
	  "function_en": "[vector] sqdmlsl [16]",
	  "function_cn": "[向量] 饱和加倍乘减 [16]"
	},
	{
	  "name": "vqdmlsl_s32",
	  "full name": "int64x2_t vqdmlsl_s32(int64x2_t a, int32x2_t b, int32x2_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlsl",
	  "function_en": "[vector] sqdmlsl [32]",
	  "function_cn": "[向量] 饱和加倍乘减 [32]"
	},
	{
	  "name": "vqdmlslh_s16",
	  "full name": "int32_t vqdmlslh_s16(int32_t a, int16_t b, int16_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlsl",
	  "function_en": "[scalar] sqdmlsl [16]",
	  "function_cn": "[标量] 饱和加倍乘减 [16]"
	},
	{
	  "name": "vqdmlsls_s32",
	  "full name": "int64_t vqdmlsls_s32(int64_t a, int32_t b, int32_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlsl",
	  "function_en": "[scalar] sqdmlsl [32]",
	  "function_cn": "[标量] 饱和加倍乘减 [32]"
	},
	{
	  "name": "vqdmlsl_high_s16",
	  "full name": "int32x4_t vqdmlsl_high_s16(int32x4_t a, int16x8_t b, int16x8_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlsl2",
	  "function_en": "[vector] sqdmlsl2 [16]",
	  "function_cn": "[向量] 饱和加倍乘减 [16]"
	},
	{
	  "name": "vqdmlsl_high_s32",
	  "full name": "int64x2_t vqdmlsl_high_s32(int64x2_t a, int32x4_t b, int32x4_t c)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmlsl2",
	  "function_en": "[vector] sqdmlsl2 [32]",
	  "function_cn": "[向量] 饱和加倍乘减 [32]"
	},
	{
	  "name": "vmull_s8",
	  "full name": "int16x8_t vmull_s8(int8x8_t a, int8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smull",
	  "function_en": "[vector] smull [8]",
	  "function_cn": "[向量] 长型乘 [8]"
	},
	{
	  "name": "vmull_s16",
	  "full name": "int32x4_t vmull_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smull",
	  "function_en": "[vector] smull [16]",
	  "function_cn": "[向量] 长型乘 [16]"
	},
	{
	  "name": "vmull_s32",
	  "full name": "int64x2_t vmull_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "_mm_mul_epi32",
	  "Intel Asm": "pmuldp",
	  "Arm Asm": "smull",
	  "function_en": "[vector] smull [32]",
	  "function_cn": "[向量] 长型乘 [32]"
	},
	{
	  "name": "vmull_u8",
	  "full name": "uint16x8_t vmull_u8(uint8x8_t a, uint8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umull",
	  "function_en": "[vector] umull [8]",
	  "function_cn": "[向量] 长型乘 [8]"
	},
	{
	  "name": "vmull_u16",
	  "full name": "uint32x4_t vmull_u16(uint16x4_t a, uint16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umull",
	  "function_en": "[vector] umull [16]",
	  "function_cn": "[向量] 长型乘 [16]"
	},
	{
	  "name": "vmull_u32",
	  "full name": "uint64x2_t vmull_u32(uint32x2_t a, uint32x2_t b)",
	  "Intel name": "_mm_mul_epu32",
	  "Intel Asm": "pmuludq",
	  "Arm Asm": "umull",
	  "function_en": "[vector] umull [32]",
	  "function_cn": "[向量] 长型乘 [32]"
	},
	{
	  "name": "vmull_p8",
	  "full name": "poly16x8_t vmull_p8(poly8x8_t a, poly8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "pmull",
	  "function_en": "[vector] pmull [8]",
	  "function_cn": "[向量] 长型乘 [8]"
	},
	{
	  "name": "vmull_high_s8",
	  "full name": "int16x8_t vmull_high_s8(int8x16_t a, int8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smull2",
	  "function_en": "[vector] smull2 [8]",
	  "function_cn": "[向量] 长型乘 [8]"
	},
	{
	  "name": "vmull_high_s16",
	  "full name": "int32x4_t vmull_high_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smull2",
	  "function_en": "[vector] smull2 [16]",
	  "function_cn": "[向量] 长型乘 [16]"
	},
	{
	  "name": "vmull_high_s32",
	  "full name": "int64x2_t vmull_high_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "smull2",
	  "function_en": "[vector] smull2 [32]",
	  "function_cn": "[向量] 长型乘 [32]"
	},
	{
	  "name": "vmull_high_u8",
	  "full name": "uint16x8_t vmull_high_u8(uint8x16_t a, uint8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umull2",
	  "function_en": "[vector] umull2 [8]",
	  "function_cn": "[向量] 长型乘 [8]"
	},
	{
	  "name": "vmull_high_u16",
	  "full name": "uint32x4_t vmull_high_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umull2",
	  "function_en": "[vector] umull2 [16]",
	  "function_cn": "[向量] 长型乘 [16]"
	},
	{
	  "name": "vmull_high_u32",
	  "full name": "uint64x2_t vmull_high_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "umull2",
	  "function_en": "[vector] umull2 [32]",
	  "function_cn": "[向量] 长型乘 [32]"
	},
	{
	  "name": "vmull_high_p8",
	  "full name": "poly16x8_t vmull_high_p8(poly8x16_t a, poly8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "pmull2",
	  "function_en": "[vector] pmull2 [8]",
	  "function_cn": "[向量] 长型乘 [8]"
	},
	{
	  "name": "vqdmull_s16",
	  "full name": "int32x4_t vqdmull_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmull",
	  "function_en": "[vector] sqdmull [16]",
	  "function_cn": "[向量] 饱和加倍长型乘 [16]"
	},
	{
	  "name": "vqdmull_s32",
	  "full name": "int64x2_t vqdmull_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmull",
	  "function_en": "[vector] sqdmull [32]",
	  "function_cn": "[向量] 饱和加倍长型乘 [32]"
	},
	{
	  "name": "vqdmullh_s16",
	  "full name": "int32_t vqdmullh_s16(int16_t a, int16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmull",
	  "function_en": "[scalar] sqdmull [16]",
	  "function_cn": "[标量] 饱和加倍长型乘 [16]"
	},
	{
	  "name": "vqdmulls_s32",
	  "full name": "int64_t vqdmulls_s32(int32_t a, int32_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmull",
	  "function_en": "[scalar] sqdmull [32]",
	  "function_cn": "[标量] 饱和加倍长型乘 [32]"
	},
	{
	  "name": "vqdmull_high_s16",
	  "full name": "int32x4_t vqdmull_high_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmull2",
	  "function_en": "[vector] sqdmull2 [16]",
	  "function_cn": "[向量] 饱和加倍长型乘 [16]"
	},
	{
	  "name": "vqdmull_high_s32",
	  "full name": "int64x2_t vqdmull_high_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqdmull2",
	  "function_en": "[vector] sqdmull2 [32]",
	  "function_cn": "[向量] 饱和加倍长型乘 [32]"
	},
	{
	  "name": "vsub_s8",
	  "full name": "int8x8_t vsub_s8(int8x8_t a, int8x8_t b)",
	  "Intel name": "_mm_sub_pi8",
	  "Intel Asm": "psubb",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubq_s8",
	  "full name": "int8x16_t vsubq_s8(int8x16_t a, int8x16_t b)",
	  "Intel name": "_mm_sub_epi8",
	  "Intel Asm": "psubb",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsub_s16",
	  "full name": "int16x4_t vsub_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "_mm_sub_pi16",
	  "Intel Asm": "psubw",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubq_s16",
	  "full name": "int16x8_t vsubq_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "_mm_sub_epi16",
	  "Intel Asm": "psubw",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsub_s32",
	  "full name": "int32x2_t vsub_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "_mm_sub_pi32",
	  "Intel Asm": "psubd",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubq_s32",
	  "full name": "int32x4_t vsubq_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "_mm_sub_epi32",
	  "Intel Asm": "psubd",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsub_s64",
	  "full name": "int64x1_t vsub_s64(int64x1_t a, int64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [64]",
	  "function_cn": "[向量] 减 [64]"
	},
	{
	  "name": "vsubq_s64",
	  "full name": "int64x2_t vsubq_s64(int64x2_t a, int64x2_t b)",
	  "Intel name": "_mm_sub_epi64",
	  "Intel Asm": "psubq",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [64]",
	  "function_cn": "[向量] 减 [64]"
	},
	{
	  "name": "vsub_u8",
	  "full name": "uint8x8_t vsub_u8(uint8x8_t a, uint8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubq_u8",
	  "full name": "uint8x16_t vsubq_u8(uint8x16_t a, uint8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsub_u16",
	  "full name": "uint16x4_t vsub_u16(uint16x4_t a, uint16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubq_u16",
	  "full name": "uint16x8_t vsubq_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsub_u32",
	  "full name": "uint32x2_t vsub_u32(uint32x2_t a, uint32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubq_u32",
	  "full name": "uint32x4_t vsubq_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsub_u64",
	  "full name": "uint64x1_t vsub_u64(uint64x1_t a, uint64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [64]",
	  "function_cn": "[向量] 减 [64]"
	},
	{
	  "name": "vsubq_u64",
	  "full name": "uint64x2_t vsubq_u64(uint64x2_t a, uint64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[vector] sub [64]",
	  "function_cn": "[向量] 减 [64]"
	},
	{
	  "name": "vsub_f32",
	  "full name": "float32x2_t vsub_f32(float32x2_t a, float32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fsub",
	  "function_en": "[vector] fsub [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubq_f32",
	  "full name": "float32x4_t vsubq_f32(float32x4_t a, float32x4_t b)",
	  "Intel name": "_mm_sub_ps",
	  "Intel Asm": "subps",
	  "Arm Asm": "fsub",
	  "function_en": "[vector] fsub [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsub_f64",
	  "full name": "float64x1_t vsub_f64(float64x1_t a, float64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "fsub",
	  "function_en": "[vector] fsub [64]",
	  "function_cn": "[向量] 减 [64]"
	},
	{
	  "name": "vsubq_f64",
	  "full name": "float64x2_t vsubq_f64(float64x2_t a, float64x2_t b)",
	  "Intel name": "_mm_sub_pd",
	  "Intel Asm": "subpd",
	  "Arm Asm": "fsub",
	  "function_en": "[vector] fsub [64]",
	  "function_cn": "[向量] 减 [64]"
	},
	{
	  "name": "vsubd_s64",
	  "full name": "int64_t vsubd_s64(int64_t a, int64_t b)",
	  "Intel name": "_mm_sub_si64",
	  "Intel Asm": "psubq",
	  "Arm Asm": "sub",
	  "function_en": "[scalar] sub [64]",
	  "function_cn": "[标量] 减 [64]"
	},
	{
	  "name": "vsubd_u64",
	  "full name": "uint64_t vsubd_u64(uint64_t a, uint64_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sub",
	  "function_en": "[scalar] sub [64]",
	  "function_cn": "[标量] 减 [64]"
	},
	{
	  "name": "vsubl_s8",
	  "full name": "int16x8_t vsubl_s8(int8x8_t a, int8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubl",
	  "function_en": "[vector] ssubl [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubl_s16",
	  "full name": "int32x4_t vsubl_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubl",
	  "function_en": "[vector] ssubl [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubl_s32",
	  "full name": "int64x2_t vsubl_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubl",
	  "function_en": "[vector] ssubl [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubl_u8",
	  "full name": "uint16x8_t vsubl_u8(uint8x8_t a, uint8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubl",
	  "function_en": "[vector] usubl [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubl_u16",
	  "full name": "uint32x4_t vsubl_u16(uint16x4_t a, uint16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubl",
	  "function_en": "[vector] usubl [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubl_u32",
	  "full name": "uint64x2_t vsubl_u32(uint32x2_t a, uint32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubl",
	  "function_en": "[vector] usubl [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubl_high_s8",
	  "full name": "int16x8_t vsubl_high_s8(int8x16_t a, int8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubl2",
	  "function_en": "[vector] ssubl2 [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubl_high_s16",
	  "full name": "int32x4_t vsubl_high_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubl2",
	  "function_en": "[vector] ssubl2 [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubl_high_s32",
	  "full name": "int64x2_t vsubl_high_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubl2",
	  "function_en": "[vector] ssubl2 [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubl_high_u8",
	  "full name": "uint16x8_t vsubl_high_u8(uint8x16_t a, uint8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubl2",
	  "function_en": "[vector] usubl2 [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubl_high_u16",
	  "full name": "uint32x4_t vsubl_high_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubl2",
	  "function_en": "[vector] usubl2 [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubl_high_u32",
	  "full name": "uint64x2_t vsubl_high_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubl2",
	  "function_en": "[vector] usubl2 [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubw_s8",
	  "full name": "int16x8_t vsubw_s8(int16x8_t a, int8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubw",
	  "function_en": "[vector] ssubw [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubw_s16",
	  "full name": "int32x4_t vsubw_s16(int32x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubw",
	  "function_en": "[vector] ssubw [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubw_s32",
	  "full name": "int64x2_t vsubw_s32(int64x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubw",
	  "function_en": "[vector] ssubw [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubw_u8",
	  "full name": "uint16x8_t vsubw_u8(uint16x8_t a, uint8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubw",
	  "function_en": "[vector] usubw [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubw_u16",
	  "full name": "uint32x4_t vsubw_u16(uint32x4_t a, uint16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubw",
	  "function_en": "[vector] usubw [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubw_u32",
	  "full name": "uint64x2_t vsubw_u32(uint64x2_t a, uint32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubw",
	  "function_en": "[vector] usubw [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubw_high_s8",
	  "full name": "int16x8_t vsubw_high_s8(int16x8_t a, int8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubw2",
	  "function_en": "[vector] ssubw2 [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubw_high_s16",
	  "full name": "int32x4_t vsubw_high_s16(int32x4_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubw2",
	  "function_en": "[vector] ssubw2 [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubw_high_s32",
	  "full name": "int64x2_t vsubw_high_s32(int64x2_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "ssubw2",
	  "function_en": "[vector] ssubw2 [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vsubw_high_u8",
	  "full name": "uint16x8_t vsubw_high_u8(uint16x8_t a, uint8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubw2",
	  "function_en": "[vector] usubw2 [8]",
	  "function_cn": "[向量] 减 [8]"
	},
	{
	  "name": "vsubw_high_u16",
	  "full name": "uint32x4_t vsubw_high_u16(uint32x4_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubw2",
	  "function_en": "[vector] usubw2 [16]",
	  "function_cn": "[向量] 减 [16]"
	},
	{
	  "name": "vsubw_high_u32",
	  "full name": "uint64x2_t vsubw_high_u32(uint64x2_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "usubw2",
	  "function_en": "[vector] usubw2 [32]",
	  "function_cn": "[向量] 减 [32]"
	},
	{
	  "name": "vhsub_s8",
	  "full name": "int8x8_t vhsub_s8(int8x8_t a, int8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "shsub",
	  "function_en": "[vector] shsub [8]",
	  "function_cn": "[向量] 相减并右移一位 [8]"
	},
	{
	  "name": "vhsubq_s8",
	  "full name": "int8x16_t vhsubq_s8(int8x16_t a, int8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "shsub",
	  "function_en": "[vector] shsub [8]",
	  "function_cn": "[向量] 相减并右移一位 [8]"
	},
	{
	  "name": "vhsub_s16",
	  "full name": "int16x4_t vhsub_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "shsub",
	  "function_en": "[vector] shsub [16]",
	  "function_cn": "[向量] 相减并右移一位 [16]"
	},
	{
	  "name": "vhsubq_s16",
	  "full name": "int16x8_t vhsubq_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "shsub",
	  "function_en": "[vector] shsub [16]",
	  "function_cn": "[向量] 相减并右移一位 [16]"
	},
	{
	  "name": "vhsub_s32",
	  "full name": "int32x2_t vhsub_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "shsub",
	  "function_en": "[vector] shsub [32]",
	  "function_cn": "[向量] 相减并右移一位 [32]"
	},
	{
	  "name": "vhsubq_s32",
	  "full name": "int32x4_t vhsubq_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "shsub",
	  "function_en": "[vector] shsub [32]",
	  "function_cn": "[向量] 相减并右移一位 [32]"
	},
	{
	  "name": "vhsub_u8",
	  "full name": "uint8x8_t vhsub_u8(uint8x8_t a, uint8x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uhsub",
	  "function_en": "[vector] uhsub [8]",
	  "function_cn": "[向量] 相减并右移一位 [8]"
	},
	{
	  "name": "vhsubq_u8",
	  "full name": "uint8x16_t vhsubq_u8(uint8x16_t a, uint8x16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uhsub",
	  "function_en": "[vector] uhsub [8]",
	  "function_cn": "[向量] 相减并右移一位 [8]"
	},
	{
	  "name": "vhsub_u16",
	  "full name": "uint16x4_t vhsub_u16(uint16x4_t a, uint16x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uhsub",
	  "function_en": "[vector] uhsub [16]",
	  "function_cn": "[向量] 相减并右移一位 [16]"
	},
	{
	  "name": "vhsubq_u16",
	  "full name": "uint16x8_t vhsubq_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uhsub",
	  "function_en": "[vector] uhsub [16]",
	  "function_cn": "[向量] 相减并右移一位 [16]"
	},
	{
	  "name": "vhsub_u32",
	  "full name": "uint32x2_t vhsub_u32(uint32x2_t a, uint32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uhsub",
	  "function_en": "[vector] uhsub [32]",
	  "function_cn": "[向量] 相减并右移一位 [32]"
	},
	{
	  "name": "vhsubq_u32",
	  "full name": "uint32x4_t vhsubq_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uhsub",
	  "function_en": "[vector] uhsub [32]",
	  "function_cn": "[向量] 相减并右移一位 [32]"
	},
	{
	  "name": "vqsub_s8",
	  "full name": "int8x8_t vqsub_s8(int8x8_t a, int8x8_t b)",
	  "Intel name": "_mm_subs_pi8",
	  "Intel Asm": "psubsb",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [8]",
	  "function_cn": "[向量] 饱和减 [8]"
	},
	{
	  "name": "vqsubq_s8",
	  "full name": "int8x16_t vqsubq_s8(int8x16_t a, int8x16_t b)",
	  "Intel name": "_mm_subs_epi8",
	  "Intel Asm": "psubsb",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [8]",
	  "function_cn": "[向量] 饱和减 [8]"
	},
	{
	  "name": "vqsub_s16",
	  "full name": "int16x4_t vqsub_s16(int16x4_t a, int16x4_t b)",
	  "Intel name": "_mm_subs_pi16",
	  "Intel Asm": "psubsw",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [16]",
	  "function_cn": "[向量] 饱和减 [16]"
	},
	{
	  "name": "vqsubq_s16",
	  "full name": "int16x8_t vqsubq_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "_mm_subs_epi16",
	  "Intel Asm": "psubsw",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [16]",
	  "function_cn": "[向量] 饱和减 [16]"
	},
	{
	  "name": "vqsub_s32",
	  "full name": "int32x2_t vqsub_s32(int32x2_t a, int32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [32]",
	  "function_cn": "[向量] 饱和减 [32]"
	},
	{
	  "name": "vqsubq_s32",
	  "full name": "int32x4_t vqsubq_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [32]",
	  "function_cn": "[向量] 饱和减 [32]"
	},
	{
	  "name": "vqsub_s64",
	  "full name": "int64x1_t vqsub_s64(int64x1_t a, int64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [64]",
	  "function_cn": "[向量] 饱和减 [64]"
	},
	{
	  "name": "vqsubq_s64",
	  "full name": "int64x2_t vqsubq_s64(int64x2_t a, int64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[vector] sqsub [64]",
	  "function_cn": "[向量] 饱和减 [64]"
	},
	{
	  "name": "vqsub_u8",
	  "full name": "uint8x8_t vqsub_u8(uint8x8_t a, uint8x8_t b)",
	  "Intel name": "_mm_subs_pu8",
	  "Intel Asm": "psubusb",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [8]",
	  "function_cn": "[向量] 饱和减 [8]"
	},
	{
	  "name": "vqsubq_u8",
	  "full name": "uint8x16_t vqsubq_u8(uint8x16_t a, uint8x16_t b)",
	  "Intel name": "_mm_subs_epu8",
	  "Intel Asm": "psubusb",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [8]",
	  "function_cn": "[向量] 饱和减 [8]"
	},
	{
	  "name": "vqsub_u16",
	  "full name": "uint16x4_t vqsub_u16(uint16x4_t a, uint16x4_t b)",
	  "Intel name": "_mm_subs_pu16",
	  "Intel Asm": "psubusw",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [16]",
	  "function_cn": "[向量] 饱和减 [16]"
	},
	{
	  "name": "vqsubq_u16",
	  "full name": "uint16x8_t vqsubq_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "_mm_subs_epu16",
	  "Intel Asm": "psubusw",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [16]",
	  "function_cn": "[向量] 饱和减 [16]"
	},
	{
	  "name": "vqsub_u32",
	  "full name": "uint32x2_t vqsub_u32(uint32x2_t a, uint32x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [32]",
	  "function_cn": "[向量] 饱和减 [32]"
	},
	{
	  "name": "vqsubq_u32",
	  "full name": "uint32x4_t vqsubq_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [32]",
	  "function_cn": "[向量] 饱和减 [32]"
	},
	{
	  "name": "vqsub_u64",
	  "full name": "uint64x1_t vqsub_u64(uint64x1_t a, uint64x1_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [64]",
	  "function_cn": "[向量] 饱和减 [64]"
	},
	{
	  "name": "vqsubq_u64",
	  "full name": "uint64x2_t vqsubq_u64(uint64x2_t a, uint64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[vector] uqsub [64]",
	  "function_cn": "[向量] 饱和减 [64]"
	},
	{
	  "name": "vqsubb_s8",
	  "full name": "int8_t vqsubb_s8(int8_t a, int8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[scalar] sqsub [8]",
	  "function_cn": "[标量] 饱和减 [8]"
	},
	{
	  "name": "vqsubh_s16",
	  "full name": "int16_t vqsubh_s16(int16_t a, int16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[scalar] sqsub [16]",
	  "function_cn": "[标量] 饱和减 [16]"
	},
	{
	  "name": "vqsubs_s32",
	  "full name": "int32_t vqsubs_s32(int32_t a, int32_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[scalar] sqsub [32]",
	  "function_cn": "[标量] 饱和减 [32]"
	},
	{
	  "name": "vqsubd_s64",
	  "full name": "int64_t vqsubd_s64(int64_t a, int64_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "sqsub",
	  "function_en": "[scalar] sqsub [64]",
	  "function_cn": "[标量] 饱和减 [64]"
	},
	{
	  "name": "vqsubb_u8",
	  "full name": "uint8_t vqsubb_u8(uint8_t a, uint8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[scalar] uqsub [8]",
	  "function_cn": "[标量] 饱和减 [8]"
	},
	{
	  "name": "vqsubh_u16",
	  "full name": "uint16_t vqsubh_u16(uint16_t a, uint16_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[scalar] uqsub [16]",
	  "function_cn": "[标量] 饱和减 [16]"
	},
	{
	  "name": "vqsubs_u32",
	  "full name": "uint32_t vqsubs_u32(uint32_t a, uint32_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[scalar] uqsub [32]",
	  "function_cn": "[标量] 饱和减 [32]"
	},
	{
	  "name": "vqsubd_u64",
	  "full name": "uint64_t vqsubd_u64(uint64_t a, uint64_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "uqsub",
	  "function_en": "[scalar] uqsub [64]",
	  "function_cn": "[标量] 饱和减 [64]"
	},
	{
	  "name": "vsubhn_s16",
	  "full name": "int8x8_t vsubhn_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn",
	  "function_en": "[vector] subhn [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vsubhn_s32",
	  "full name": "int16x4_t vsubhn_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn",
	  "function_en": "[vector] subhn [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vsubhn_s64",
	  "full name": "int32x2_t vsubhn_s64(int64x2_t a, int64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn",
	  "function_en": "[vector] subhn [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vsubhn_u16",
	  "full name": "uint8x8_t vsubhn_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn",
	  "function_en": "[vector] subhn [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vsubhn_u32",
	  "full name": "uint16x4_t vsubhn_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn",
	  "function_en": "[vector] subhn [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vsubhn_u64",
	  "full name": "uint32x2_t vsubhn_u64(uint64x2_t a, uint64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn",
	  "function_en": "[vector] subhn [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vsubhn_high_s16",
	  "full name": "int8x16_t vsubhn_high_s16(int8x8_t r, int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn2",
	  "function_en": "[vector] subhn2 [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vsubhn_high_s32",
	  "full name": "int16x8_t vsubhn_high_s32(int16x4_t r, int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn2",
	  "function_en": "[vector] subhn2 [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vsubhn_high_s64",
	  "full name": "int32x4_t vsubhn_high_s64(int32x2_t r, int64x2_t a, int64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn2",
	  "function_en": "[vector] subhn2 [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vsubhn_high_u16",
	  "full name": "uint8x16_t vsubhn_high_u16(uint8x8_t r, uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn2",
	  "function_en": "[vector] subhn2 [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vsubhn_high_u32",
	  "full name": "uint16x8_t vsubhn_high_u32(uint16x4_t r, uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn2",
	  "function_en": "[vector] subhn2 [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vsubhn_high_u64",
	  "full name": "uint32x4_t vsubhn_high_u64(uint32x2_t r, uint64x2_t a, uint64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "subhn2",
	  "function_en": "[vector] subhn2 [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vrsubhn_s16",
	  "full name": "int8x8_t vrsubhn_s16(int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn",
	  "function_en": "[vector] rsubhn [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vrsubhn_s32",
	  "full name": "int16x4_t vrsubhn_s32(int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn",
	  "function_en": "[vector] rsubhn [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vrsubhn_s64",
	  "full name": "int32x2_t vrsubhn_s64(int64x2_t a, int64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn",
	  "function_en": "[vector] rsubhn [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vrsubhn_u16",
	  "full name": "uint8x8_t vrsubhn_u16(uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn",
	  "function_en": "[vector] rsubhn [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vrsubhn_u32",
	  "full name": "uint16x4_t vrsubhn_u32(uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn",
	  "function_en": "[vector] rsubhn [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vrsubhn_u64",
	  "full name": "uint32x2_t vrsubhn_u64(uint64x2_t a, uint64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn",
	  "function_en": "[vector] rsubhn [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vrsubhn_high_s16",
	  "full name": "int8x16_t vrsubhn_high_s16(int8x8_t r, int16x8_t a, int16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn2",
	  "function_en": "[vector] rsubhn2 [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vrsubhn_high_s32",
	  "full name": "int16x8_t vrsubhn_high_s32(int16x4_t r, int32x4_t a, int32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn2",
	  "function_en": "[vector] rsubhn2 [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vrsubhn_high_s64",
	  "full name": "int32x4_t vrsubhn_high_s64(int32x2_t r, int64x2_t a, int64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn2",
	  "function_en": "[vector] rsubhn2 [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
	{
	  "name": "vrsubhn_high_u16",
	  "full name": "uint8x16_t vrsubhn_high_u16(uint8x8_t r, uint16x8_t a, uint16x8_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn2",
	  "function_en": "[vector] rsubhn2 [16]",
	  "function_cn": "[向量] 窄型减 [16]"
	},
	{
	  "name": "vrsubhn_high_u32",
	  "full name": "uint16x8_t vrsubhn_high_u32(uint16x4_t r, uint32x4_t a, uint32x4_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn2",
	  "function_en": "[vector] rsubhn2 [32]",
	  "function_cn": "[向量] 窄型减 [32]"
	},
	{
	  "name": "vrsubhn_high_u64",
	  "full name": "uint32x4_t vrsubhn_high_u64(uint32x2_t r, uint64x2_t a, uint64x2_t b)",
	  "Intel name": "",
	  "Intel Asm": "",
	  "Arm Asm": "rsubhn2",
	  "function_en": "[vector] rsubhn2 [64]",
	  "function_cn": "[向量] 窄型减 [64]"
	},
    {
      "name": "vceq_s8",
      "full name": "uint8x8_t vceq_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "_mm_cmpeq_pi8",
      "Intel Asm": "pcmpeqb",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较等于 [8]"
    },
    {
      "name": "vceqq_s8",
      "full name": "uint8x16_t vceqq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "_mm_cmpeq_epi8",
      "Intel Asm": "pcmpeqb",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较等于 [8]"
    },
    {
      "name": "vceq_s16",
      "full name": "uint16x4_t vceq_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "_mm_cmpeq_pi16",
      "Intel Asm": "pcmpeqw",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较等于 [16]"
    },
    {
      "name": "vceqq_s16",
      "full name": "uint16x8_t vceqq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "_mm_cmpeq_epi16",
      "Intel Asm": "pcmpeqw",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较等于 [16]"
    },
    {
      "name": "vceq_s32",
      "full name": "uint32x2_t vceq_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "_mm_cmpeq_pi32",
      "Intel Asm": "pcmpeqd",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较等于 [32]"
    },
    {
      "name": "vceqq_s32",
      "full name": "uint32x4_t vceqq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "_mm_cmpeq_epi32",
      "Intel Asm": "pcmpeqd",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较等于 [32]"
    },
    {
      "name": "vceq_u8",
      "full name": "uint8x8_t vceq_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较等于 [8]"
    },
    {
      "name": "vceqq_u8",
      "full name": "uint8x16_t vceqq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较等于 [8]"
    },
    {
      "name": "vceq_u16",
      "full name": "uint16x4_t vceq_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较等于 [16]"
    },
    {
      "name": "vceqq_u16",
      "full name": "uint16x8_t vceqq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较等于 [16]"
    },
    {
      "name": "vceq_u32",
      "full name": "uint32x2_t vceq_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较等于 [32]"
    },
    {
      "name": "vceqq_u32",
      "full name": "uint32x4_t vceqq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较等于 [32]"
    },
    {
      "name": "vceq_f32",
      "full name": "uint32x2_t vceq_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [32]",
      "function_cn": "[向量] 比较等于 [32]"
    },
    {
      "name": "vceqq_f32",
      "full name": "uint32x4_t vceqq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "_mm_cmpeq_ps",
      "Intel Asm": "cmpps",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [32]",
      "function_cn": "[向量] 比较等于 [32]"
    },
    {
      "name": "vceq_p8",
      "full name": "uint8x8_t vceq_p8(poly8x8_t a, poly8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较等于 [8]"
    },
    {
      "name": "vceqq_p8",
      "full name": "uint8x16_t vceqq_p8(poly8x16_t a, poly8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较等于 [8]"
    },
    {
      "name": "vceq_s64",
      "full name": "uint64x1_t vceq_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceqq_s64",
      "full name": "uint64x2_t vceqq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "_mm_cmpeq_epi64",
      "Intel Asm": "pcmpeqq",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceq_u64",
      "full name": "uint64x1_t vceq_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceqq_u64",
      "full name": "uint64x2_t vceqq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceq_p64",
      "full name": "uint64x1_t vceq_p64(poly64x1_t a, poly64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceqq_p64",
      "full name": "uint64x2_t vceqq_p64(poly64x2_t a, poly64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceq_f64",
      "full name": "uint64x1_t vceq_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceqq_f64",
      "full name": "uint64x2_t vceqq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "_mm_cmpeq_pd",
      "Intel Asm": "cmppd",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [64]",
      "function_cn": "[向量] 比较等于 [64]"
    },
    {
      "name": "vceqd_s64",
      "full name": "uint64_t vceqd_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[scalar] cmeq [64]",
      "function_cn": "[标量] 比较等于 [64]"
    },
    {
      "name": "vceqd_u64",
      "full name": "uint64_t vceqd_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[scalar] cmeq [64]",
      "function_cn": "[标量] 比较等于 [64]"
    },
    {
      "name": "vceqs_f32",
      "full name": "uint32_t vceqs_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[scalar] fcmeq [32]",
      "function_cn": "[标量] 比较等于 [32]"
    },
    {
      "name": "vceqd_f64",
      "full name": "uint64_t vceqd_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[scalar] fcmeq [64]",
      "function_cn": "[标量] 比较等于 [64]"
    },
    {
      "name": "vceqz_s8",
      "full name": "uint8x8_t vceqz_s8(int8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较是否等于零寄存器 [8]"
    },
    {
      "name": "vceqzq_s8",
      "full name": "uint8x16_t vceqzq_s8(int8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较是否等于零寄存器 [8]"
    },
    {
      "name": "vceqz_s16",
      "full name": "uint16x4_t vceqz_s16(int16x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较是否等于零寄存器 [16]"
    },
    {
      "name": "vceqzq_s16",
      "full name": "uint16x8_t vceqzq_s16(int16x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较是否等于零寄存器 [16]"
    },
    {
      "name": "vceqz_s32",
      "full name": "uint32x2_t vceqz_s32(int32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqzq_s32",
      "full name": "uint32x4_t vceqzq_s32(int32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqz_u8",
      "full name": "uint8x8_t vceqz_u8(uint8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较是否等于零寄存器 [8]"
    },
    {
      "name": "vceqzq_u8",
      "full name": "uint8x16_t vceqzq_u8(uint8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较是否等于零寄存器 [8]"
    },
    {
      "name": "vceqz_u16",
      "full name": "uint16x4_t vceqz_u16(uint16x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较是否等于零寄存器 [16]"
    },
    {
      "name": "vceqzq_u16",
      "full name": "uint16x8_t vceqzq_u16(uint16x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [16]",
      "function_cn": "[向量] 比较是否等于零寄存器 [16]"
    },
    {
      "name": "vceqz_u32",
      "full name": "uint32x2_t vceqz_u32(uint32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqzq_u32",
      "full name": "uint32x4_t vceqzq_u32(uint32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [32]",
      "function_cn": "[向量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqz_f32",
      "full name": "uint32x2_t vceqz_f32(float32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [32]",
      "function_cn": "[向量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqzq_f32",
      "full name": "uint32x4_t vceqzq_f32(float32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [32]",
      "function_cn": "[向量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqz_p8",
      "full name": "uint8x8_t vceqz_p8(poly8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较是否等于零寄存器 [8]"
    },
    {
      "name": "vceqzq_p8",
      "full name": "uint8x16_t vceqzq_p8(poly8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [8]",
      "function_cn": "[向量] 比较是否等于零寄存器 [8]"
    },
    {
      "name": "vceqz_s64",
      "full name": "uint64x1_t vceqz_s64(int64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzq_s64",
      "full name": "uint64x2_t vceqzq_s64(int64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqz_u64",
      "full name": "uint64x1_t vceqz_u64(uint64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzq_u64",
      "full name": "uint64x2_t vceqzq_u64(uint64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqz_p64",
      "full name": "uint64x1_t vceqz_p64(poly64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzq_p64",
      "full name": "uint64x2_t vceqzq_p64(poly64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[vector] cmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqz_f64",
      "full name": "uint64x1_t vceqz_f64(float64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzq_f64",
      "full name": "uint64x2_t vceqzq_f64(float64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[vector] fcmeq [64]",
      "function_cn": "[向量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzd_s64",
      "full name": "uint64_t vceqzd_s64(int64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[scalar] cmeq [64]",
      "function_cn": "[标量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzd_u64",
      "full name": "uint64_t vceqzd_u64(uint64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmeq",
      "function_en": "[scalar] cmeq [64]",
      "function_cn": "[标量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vceqzs_f32",
      "full name": "uint32_t vceqzs_f32(float32_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[scalar] fcmeq [32]",
      "function_cn": "[标量] 比较是否等于零寄存器 [32]"
    },
    {
      "name": "vceqzd_f64",
      "full name": "uint64_t vceqzd_f64(float64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmeq",
      "function_en": "[scalar] fcmeq [64]",
      "function_cn": "[标量] 比较是否等于零寄存器 [64]"
    },
    {
      "name": "vcge_s8",
      "full name": "uint8x8_t vcge_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [8]",
      "function_cn": "[向量] 比较大于等于 [8]"
    },
    {
      "name": "vcgeq_s8",
      "full name": "uint8x16_t vcgeq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [8]",
      "function_cn": "[向量] 比较大于等于 [8]"
    },
    {
      "name": "vcge_s16",
      "full name": "uint16x4_t vcge_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [16]",
      "function_cn": "[向量] 比较大于等于 [16]"
    },
    {
      "name": "vcgeq_s16",
      "full name": "uint16x8_t vcgeq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [16]",
      "function_cn": "[向量] 比较大于等于 [16]"
    },
    {
      "name": "vcge_s32",
      "full name": "uint32x2_t vcge_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [32]",
      "function_cn": "[向量] 比较大于等于 [32]"
    },
    {
      "name": "vcgeq_s32",
      "full name": "uint32x4_t vcgeq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [32]",
      "function_cn": "[向量] 比较大于等于 [32]"
    },
    {
      "name": "vcge_u8",
      "full name": "uint8x8_t vcge_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [8]",
      "function_cn": "[向量] 比较大于等于 [8]"
    },
    {
      "name": "vcgeq_u8",
      "full name": "uint8x16_t vcgeq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [8]",
      "function_cn": "[向量] 比较大于等于 [8]"
    },
    {
      "name": "vcge_u16",
      "full name": "uint16x4_t vcge_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [16]",
      "function_cn": "[向量] 比较大于等于 [16]"
    },
    {
      "name": "vcgeq_u16",
      "full name": "uint16x8_t vcgeq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [16]",
      "function_cn": "[向量] 比较大于等于 [16]"
    },
    {
      "name": "vcge_u32",
      "full name": "uint32x2_t vcge_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [32]",
      "function_cn": "[向量] 比较大于等于 [32]"
    },
    {
      "name": "vcgeq_u32",
      "full name": "uint32x4_t vcgeq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [32]",
      "function_cn": "[向量] 比较大于等于 [32]"
    },
    {
      "name": "vcge_f32",
      "full name": "uint32x2_t vcge_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [32]",
      "function_cn": "[向量] 比较大于等于 [32]"
    },
    {
      "name": "vcgeq_f32",
      "full name": "uint32x4_t vcgeq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "_mm_cmpge_ps",
      "Intel Asm": "cmpps",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [32]",
      "function_cn": "[向量] 比较大于等于 [32]"
    },
    {
      "name": "vcge_s64",
      "full name": "uint64x1_t vcge_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [64]",
      "function_cn": "[向量] 比较大于等于 [64]"
    },
    {
      "name": "vcgeq_s64",
      "full name": "uint64x2_t vcgeq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [64]",
      "function_cn": "[向量] 比较大于等于 [64]"
    },
    {
      "name": "vcge_u64",
      "full name": "uint64x1_t vcge_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [64]",
      "function_cn": "[向量] 比较大于等于 [64]"
    },
    {
      "name": "vcgeq_u64",
      "full name": "uint64x2_t vcgeq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [64]",
      "function_cn": "[向量] 比较大于等于 [64]"
    },
    {
      "name": "vcge_f64",
      "full name": "uint64x1_t vcge_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [64]",
      "function_cn": "[向量] 比较大于等于 [64]"
    },
    {
      "name": "vcgeq_f64",
      "full name": "uint64x2_t vcgeq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "_mm_cmpge_pd",
      "Intel Asm": "cmppd",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [64]",
      "function_cn": "[向量] 比较大于等于 [64]"
    },
    {
      "name": "vcged_s64",
      "full name": "uint64_t vcged_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[scalar] cmge [64]",
      "function_cn": "[标量] 比较大于等于 [64]"
    },
    {
      "name": "vcged_u64",
      "full name": "uint64_t vcged_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[scalar] cmhs [64]",
      "function_cn": "[标量] 比较大于等于 [64]"
    },
    {
      "name": "vcges_f32",
      "full name": "uint32_t vcges_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[scalar] fcmge [32]",
      "function_cn": "[标量] 比较大于等于 [32]"
    },
    {
      "name": "vcged_f64",
      "full name": "uint64_t vcged_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[scalar] fcmge [32]",
      "function_cn": "[标量] 比较大于等于 [32]"
    },
    {
      "name": "vcgez_s8",
      "full name": "uint8x8_t vcgez_s8(int8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [8]",
      "function_cn": "[向量] 比较大于等于零寄存器 [8]"
    },
    {
      "name": "vcgezq_s8",
      "full name": "uint8x16_t vcgezq_s8(int8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [8]",
      "function_cn": "[向量] 比较大于等于零寄存器 [8]"
    },
    {
      "name": "vcgez_s16",
      "full name": "uint16x4_t vcgez_s16(int16x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [16]",
      "function_cn": "[向量] 比较大于等于零寄存器 [16]"
    },
    {
      "name": "vcgezq_s16",
      "full name": "uint16x8_t vcgezq_s16(int16x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [16]",
      "function_cn": "[向量] 比较大于等于零寄存器 [16]"
    },
    {
      "name": "vcgez_s32",
      "full name": "uint32x2_t vcgez_s32(int32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [32]",
      "function_cn": "[向量] 比较大于等于零寄存器 [32]"
    },
    {
      "name": "vcgezq_s32",
      "full name": "uint32x4_t vcgezq_s32(int32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [32]",
      "function_cn": "[向量] 比较大于等于零寄存器 [32]"
    },
    {
      "name": "vcgez_s64",
      "full name": "uint64x1_t vcgez_s64(int64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [64]",
      "function_cn": "[向量] 比较大于等于零寄存器 [64]"
    },
    {
      "name": "vcgezq_s64",
      "full name": "uint64x2_t vcgezq_s64(int64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [64]",
      "function_cn": "[向量] 比较大于等于零寄存器 [64]"
    },
    {
      "name": "vcgez_f32",
      "full name": "uint32x2_t vcgez_f32(float32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [32]",
      "function_cn": "[向量] 比较大于等于零寄存器 [32]"
    },
    {
      "name": "vcgezq_f32",
      "full name": "uint32x4_t vcgezq_f32(float32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [32]",
      "function_cn": "[向量] 比较大于等于零寄存器 [32]"
    },
    {
      "name": "vcgez_f64",
      "full name": "uint64x1_t vcgez_f64(float64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [64]",
      "function_cn": "[向量] 比较大于等于零寄存器 [64]"
    },
    {
      "name": "vcgezq_f64",
      "full name": "uint64x2_t vcgezq_f64(float64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [64]",
      "function_cn": "[向量] 比较大于等于零寄存器 [64]"
    },
    {
      "name": "vcgezd_s64",
      "full name": "uint64_t vcgezd_s64(int64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[scalar] cmge [64]",
      "function_cn": "[标量] 比较大于等于零寄存器 [64]"
    },
    {
      "name": "vcgezs_f32",
      "full name": "uint32_t vcgezs_f32(float32_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[scalar] fcmge [32]",
      "function_cn": "[标量] 比较大于等于零寄存器 [32]"
    },
    {
      "name": "vcgezd_f64",
      "full name": "uint64_t vcgezd_f64(float64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[scalar] fcmge [64]",
      "function_cn": "[标量] 比较大于等于零寄存器 [64]"
    },
    {
      "name": "vcle_s8",
      "full name": "uint8x8_t vcle_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [8]",
      "function_cn": "[向量] 比较小于等于 [8]"
    },
    {
      "name": "vcleq_s8",
      "full name": "uint8x16_t vcleq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [8]",
      "function_cn": "[向量] 比较小于等于 [8]"
    },
    {
      "name": "vcle_s16",
      "full name": "uint16x4_t vcle_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [16]",
      "function_cn": "[向量] 比较小于等于 [16]"
    },
    {
      "name": "vcleq_s16",
      "full name": "uint16x8_t vcleq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [16]",
      "function_cn": "[向量] 比较小于等于 [16]"
    },
    {
      "name": "vcle_s32",
      "full name": "uint32x2_t vcle_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [32]",
      "function_cn": "[向量] 比较小于等于 [32]"
    },
    {
      "name": "vcleq_s32",
      "full name": "uint32x4_t vcleq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [32]",
      "function_cn": "[向量] 比较小于等于 [32]"
    },
    {
      "name": "vcle_u8",
      "full name": "uint8x8_t vcle_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [8]",
      "function_cn": "[向量] 比较小于等于 [8]"
    },
    {
      "name": "vcleq_u8",
      "full name": "uint8x16_t vcleq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [8]",
      "function_cn": "[向量] 比较小于等于 [8]"
    },
    {
      "name": "vcle_u16",
      "full name": "uint16x4_t vcle_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [16]",
      "function_cn": "[向量] 比较小于等于 [16]"
    },
    {
      "name": "vcleq_u16",
      "full name": "uint16x8_t vcleq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [16]",
      "function_cn": "[向量] 比较小于等于 [16]"
    },
    {
      "name": "vcle_u32",
      "full name": "uint32x2_t vcle_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [32]",
      "function_cn": "[向量] 比较小于等于 [32]"
    },
    {
      "name": "vcleq_u32",
      "full name": "uint32x4_t vcleq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [32]",
      "function_cn": "[向量] 比较小于等于 [32]"
    },
    {
      "name": "vcle_f32",
      "full name": "uint32x2_t vcle_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [32]",
      "function_cn": "[向量] 比较小于等于 [32]"
    },
    {
      "name": "vcleq_f32",
      "full name": "uint32x4_t vcleq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "_mm_cmple_ps",
      "Intel Asm": "cmpps",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [32]",
      "function_cn": "[向量] 比较小于等于 [32]"
    },
    {
      "name": "vcle_s64",
      "full name": "uint64x1_t vcle_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [64]",
      "function_cn": "[向量] 比较小于等于 [64]"
    },
    {
      "name": "vcleq_s64",
      "full name": "uint64x2_t vcleq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[vector] cmge [64]",
      "function_cn": "[向量] 比较小于等于 [64]"
    },
    {
      "name": "vcle_u64",
      "full name": "uint64x1_t vcle_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [64]",
      "function_cn": "[向量] 比较小于等于 [64]"
    },
    {
      "name": "vcleq_u64",
      "full name": "uint64x2_t vcleq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[vector] cmhs [64]",
      "function_cn": "[向量] 比较小于等于 [64]"
    },
    {
      "name": "vcle_f64",
      "full name": "uint64x1_t vcle_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [64]",
      "function_cn": "[向量] 比较小于等于 [64]"
    },
    {
      "name": "vcleq_f64",
      "full name": "uint64x2_t vcleq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "_mm_cmple_pd",
      "Intel Asm": "cmppd",
      "Arm Asm": "fcmge",
      "function_en": "[vector] fcmge [64]",
      "function_cn": "[向量] 比较小于等于 [64]"
    },
    {
      "name": "vcled_s64",
      "full name": "uint64_t vcled_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmge",
      "function_en": "[scalar] cmge [64]",
      "function_cn": "[标量] 比较小于等于 [64]"
    },
    {
      "name": "vcled_u64",
      "full name": "uint64_t vcled_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhs",
      "function_en": "[scalar] cmhs [64]",
      "function_cn": "[标量] 比较小于等于 [64]"
    },
    {
      "name": "vcles_f32",
      "full name": "uint32_t vcles_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[scalar] fcmge [32]",
      "function_cn": "[标量] 比较小于等于 [32]"
    },
    {
      "name": "vcled_f64",
      "full name": "uint64_t vcled_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmge",
      "function_en": "[scalar] fcmge [32]",
      "function_cn": "[标量] 比较小于等于 [32]"
    },
    {
      "name": "vclez_s8",
      "full name": "uint8x8_t vclez_s8(int8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [8]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [8]"
    },
    {
      "name": "vclezq_s8",
      "full name": "uint8x16_t vclezq_s8(int8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [8]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [8]"
    },
    {
      "name": "vclez_s16",
      "full name": "uint16x4_t vclez_s16(int16x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [16]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [16]"
    },
    {
      "name": "vclezq_s16",
      "full name": "uint16x8_t vclezq_s16(int16x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [16]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [16]"
    },
    {
      "name": "vclez_s32",
      "full name": "uint32x2_t vclez_s32(int32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [32]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [32]"
    },
    {
      "name": "vclezq_s32",
      "full name": "uint32x4_t vclezq_s32(int32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [32]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [32]"
    },
    {
      "name": "vclez_s64",
      "full name": "uint64x1_t vclez_s64(int64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [64]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [64]"
    },
    {
      "name": "vclezq_s64",
      "full name": "uint64x2_t vclezq_s64(int64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [64]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [64]"
    },
    {
      "name": "vclez_f32",
      "full name": "uint32x2_t vclez_f32(float32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[vector] cmle [32]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [32]"
    },
    {
      "name": "vclezq_f32",
      "full name": "uint32x4_t vclezq_f32(float32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmle",
      "function_en": "[vector] fcmle [32]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [32]"
    },
    {
      "name": "vclez_f64",
      "full name": "uint64x1_t vclez_f64(float64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmle",
      "function_en": "[vector] fcmle [64]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [64]"
    },
    {
      "name": "vclezq_f64",
      "full name": "uint64x2_t vclezq_f64(float64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmle",
      "function_en": "[vector] fcmle [64]",
      "function_cn": "[向量] 比较是否小于等于零寄存器 [64]"
    },
    {
      "name": "vclezd_s64",
      "full name": "uint64_t vclezd_s64(int64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmle",
      "function_en": "[scalar] cmle [64]",
      "function_cn": "[标量] 比较是否小于等于零寄存器 [64]"
    },
    {
      "name": "vclezs_f32",
      "full name": "uint32_t vclezs_f32(float32_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmle",
      "function_en": "[scalar] fcmle [32]",
      "function_cn": "[标量] 比较是否小于等于零寄存器 [32]"
    },
    {
      "name": "vclezd_f64",
      "full name": "uint64_t vclezd_f64(float64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmle",
      "function_en": "[scalar] fcmle [64]",
      "function_cn": "[标量] 比较是否小于等于零寄存器 [64]"
    },
    {
      "name": "vcgt_s8",
      "full name": "uint8x8_t vcgt_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "_mm_cmpgt_pi8",
      "Intel Asm": "pcmpgtb",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [8]",
      "function_cn": "[向量] 比较大于 [8]"
    },
    {
      "name": "vcgtq_s8",
      "full name": "uint8x16_t vcgtq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "_mm_cmpgt_epi8",
      "Intel Asm": "pcmpgtb",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [8]",
      "function_cn": "[向量] 比较大于 [8]"
    },
    {
      "name": "vcgt_s16",
      "full name": "uint16x4_t vcgt_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "_mm_cmpgt_pi16",
      "Intel Asm": "pcmpgtw",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [16]",
      "function_cn": "[向量] 比较大于 [16]"
    },
    {
      "name": "vcgtq_s16",
      "full name": "uint16x8_t vcgtq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "_mm_cmpgt_epi16",
      "Intel Asm": "pcmpgtw",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [16]",
      "function_cn": "[向量] 比较大于 [16]"
    },
    {
      "name": "vcgt_s32",
      "full name": "uint32x2_t vcgt_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "_mm_cmpgt_pi32",
      "Intel Asm": "pcmpgtd",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [32]",
      "function_cn": "[向量] 比较大于 [32]"
    },
    {
      "name": "vcgtq_s32",
      "full name": "uint32x4_t vcgtq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "_mm_cmpgt_epi32",
      "Intel Asm": "pcmpgtd",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [32]",
      "function_cn": "[向量] 比较大于 [32]"
    },
    {
      "name": "vcgt_u8",
      "full name": "uint8x8_t vcgt_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [8]",
      "function_cn": "[向量] 比较大于 [8]"
    },
    {
      "name": "vcgtq_u8",
      "full name": "uint8x16_t vcgtq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [8]",
      "function_cn": "[向量] 比较大于 [8]"
    },
    {
      "name": "vcgt_u16",
      "full name": "uint16x4_t vcgt_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [16]",
      "function_cn": "[向量] 比较大于 [16]"
    },
    {
      "name": "vcgtq_u16",
      "full name": "uint16x8_t vcgtq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [16]",
      "function_cn": "[向量] 比较大于 [16]"
    },
    {
      "name": "vcgt_u32",
      "full name": "uint32x2_t vcgt_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [32]",
      "function_cn": "[向量] 比较大于 [32]"
    },
    {
      "name": "vcgtq_u32",
      "full name": "uint32x4_t vcgtq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [32]",
      "function_cn": "[向量] 比较大于 [32]"
    },
    {
      "name": "vcgt_f32",
      "full name": "uint32x2_t vcgt_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [32]",
      "function_cn": "[向量] 比较大于 [32]"
    },
    {
      "name": "vcgtq_f32",
      "full name": "uint32x4_t vcgtq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "_mm_cmpgt_ps",
      "Intel Asm": "cmpps",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [32]",
      "function_cn": "[向量] 比较大于 [32]"
    },
    {
      "name": "vcgt_s64",
      "full name": "uint64x1_t vcgt_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [64]",
      "function_cn": "[向量] 比较大于 [64]"
    },
    {
      "name": "vcgtq_s64",
      "full name": "uint64x2_t vcgtq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "_mm_cmpgt_epi64",
      "Intel Asm": "pcmpgtq",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [64]",
      "function_cn": "[向量] 比较大于 [64]"
    },
    {
      "name": "vcgt_u64",
      "full name": "uint64x1_t vcgt_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [64]",
      "function_cn": "[向量] 比较大于 [64]"
    },
    {
      "name": "vcgtq_u64",
      "full name": "uint64x2_t vcgtq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [64]",
      "function_cn": "[向量] 比较大于 [64]"
    },
    {
      "name": "vcgt_f64",
      "full name": "uint64x1_t vcgt_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [64]",
      "function_cn": "[向量] 比较大于 [64]"
    },
    {
      "name": "vcgtq_f64",
      "full name": "uint64x2_t vcgtq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "_mm_cmpgt_pd",
      "Intel Asm": "cmppd",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [64]",
      "function_cn": "[向量] 比较大于 [64]"
    },
    {
      "name": "vcgtd_s64",
      "full name": "uint64_t vcgtd_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[scalar] cmgt [64]",
      "function_cn": "[标量] 比较大于 [64]"
    },
    {
      "name": "vcgtd_u64",
      "full name": "uint64_t vcgtd_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[scalar] cmhi [0]",
      "function_cn": "[标量] 比较大于 [0]"
    },
    {
      "name": "vcgts_f32",
      "full name": "uint32_t vcgts_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[scalar] fcmgt [0]",
      "function_cn": "[标量] 比较大于 [0]"
    },
    {
      "name": "vcgtd_f64",
      "full name": "uint64_t vcgtd_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[scalar] fcmgt [0]",
      "function_cn": "[标量] 比较大于 [0]"
    },
    {
      "name": "vcgtz_s8",
      "full name": "uint8x8_t vcgtz_s8(int8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [8]",
      "function_cn": "[向量] 比较是否大于零寄存器 [8]"
    },
    {
      "name": "vcgtzq_s8",
      "full name": "uint8x16_t vcgtzq_s8(int8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [8]",
      "function_cn": "[向量] 比较是否大于零寄存器 [8]"
    },
    {
      "name": "vcgtz_s16",
      "full name": "uint16x4_t vcgtz_s16(int16x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [16]",
      "function_cn": "[向量] 比较是否大于零寄存器 [16]"
    },
    {
      "name": "vcgtzq_s16",
      "full name": "uint16x8_t vcgtzq_s16(int16x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [16]",
      "function_cn": "[向量] 比较是否大于零寄存器 [16]"
    },
    {
      "name": "vcgtz_s32",
      "full name": "uint32x2_t vcgtz_s32(int32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [32]",
      "function_cn": "[向量] 比较是否大于零寄存器 [32]"
    },
    {
      "name": "vcgtzq_s32",
      "full name": "uint32x4_t vcgtzq_s32(int32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [32]",
      "function_cn": "[向量] 比较是否大于零寄存器 [32]"
    },
    {
      "name": "vcgtz_s64",
      "full name": "uint64x1_t vcgtz_s64(int64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [64]",
      "function_cn": "[向量] 比较是否大于零寄存器 [64]"
    },
    {
      "name": "vcgtzq_s64",
      "full name": "uint64x2_t vcgtzq_s64(int64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [64]",
      "function_cn": "[向量] 比较是否大于零寄存器 [64]"
    },
    {
      "name": "vcgtz_f32",
      "full name": "uint32x2_t vcgtz_f32(float32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [32]",
      "function_cn": "[向量] 比较是否大于零寄存器 [32]"
    },
    {
      "name": "vcgtzq_f32",
      "full name": "uint32x4_t vcgtzq_f32(float32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [32]",
      "function_cn": "[向量] 比较是否大于零寄存器 [32]"
    },
    {
      "name": "vcgtz_f64",
      "full name": "uint64x1_t vcgtz_f64(float64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [64]",
      "function_cn": "[向量] 比较是否大于零寄存器 [64]"
    },
    {
      "name": "vcgtzq_f64",
      "full name": "uint64x2_t vcgtzq_f64(float64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [64]",
      "function_cn": "[向量] 比较是否大于零寄存器 [64]"
    },
    {
      "name": "vcgtzd_s64",
      "full name": "uint64_t vcgtzd_s64(int64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[scalar] cmgt [64]",
      "function_cn": "[标量] 比较是否大于零寄存器 [64]"
    },
    {
      "name": "vcgtzs_f32",
      "full name": "uint32_t vcgtzs_f32(float32_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[scalar] fcmgt [32]",
      "function_cn": "[标量] 比较是否大于零寄存器 [32]"
    },
    {
      "name": "vcgtzd_f64",
      "full name": "uint64_t vcgtzd_f64(float64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[scalar] fcmgt [64]",
      "function_cn": "[标量] 比较是否大于零寄存器 [64]"
    },
    {
      "name": "vclt_s8",
      "full name": "uint8x8_t vclt_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [8]",
      "function_cn": "[向量] 比较小于 [8]"
    },
    {
      "name": "vcltq_s8",
      "full name": "uint8x16_t vcltq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "_mm_cmplt_epi8",
      "Intel Asm": "pcmpgtb",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [8]",
      "function_cn": "[向量] 比较小于 [8]"
    },
    {
      "name": "vclt_s16",
      "full name": "uint16x4_t vclt_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [16]",
      "function_cn": "[向量] 比较小于 [16]"
    },
    {
      "name": "vcltq_s16",
      "full name": "uint16x8_t vcltq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "_mm_cmplt_epi16",
      "Intel Asm": "pcmpgtw",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [16]",
      "function_cn": "[向量] 比较小于 [16]"
    },
    {
      "name": "vclt_s32",
      "full name": "uint32x2_t vclt_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [32]",
      "function_cn": "[向量] 比较小于 [32]"
    },
    {
      "name": "vcltq_s32",
      "full name": "uint32x4_t vcltq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "_mm_cmplt_epi32",
      "Intel Asm": "pcmpgtd",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [32]",
      "function_cn": "[向量] 比较小于 [32]"
    },
    {
      "name": "vclt_u8",
      "full name": "uint8x8_t vclt_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [8]",
      "function_cn": "[向量] 比较小于 [8]"
    },
    {
      "name": "vcltq_u8",
      "full name": "uint8x16_t vcltq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [8]",
      "function_cn": "[向量] 比较小于 [8]"
    },
    {
      "name": "vclt_u16",
      "full name": "uint16x4_t vclt_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [16]",
      "function_cn": "[向量] 比较小于 [16]"
    },
    {
      "name": "vcltq_u16",
      "full name": "uint16x8_t vcltq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [16]",
      "function_cn": "[向量] 比较小于 [16]"
    },
    {
      "name": "vclt_u32",
      "full name": "uint32x2_t vclt_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [32]",
      "function_cn": "[向量] 比较小于 [32]"
    },
    {
      "name": "vcltq_u32",
      "full name": "uint32x4_t vcltq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [32]",
      "function_cn": "[向量] 比较小于 [32]"
    },
    {
      "name": "vclt_f32",
      "full name": "uint32x2_t vclt_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [32]",
      "function_cn": "[向量] 比较小于 [32]"
    },
    {
      "name": "vcltq_f32",
      "full name": "uint32x4_t vcltq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "_mm_cmplt_ps",
      "Intel Asm": "cmpps",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [32]",
      "function_cn": "[向量] 比较小于 [32]"
    },
    {
      "name": "vclt_s64",
      "full name": "uint64x1_t vclt_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [64]",
      "function_cn": "[向量] 比较小于 [64]"
    },
    {
      "name": "vcltq_s64",
      "full name": "uint64x2_t vcltq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[vector] cmgt [64]",
      "function_cn": "[向量] 比较小于 [64]"
    },
    {
      "name": "vclt_u64",
      "full name": "uint64x1_t vclt_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [64]",
      "function_cn": "[向量] 比较小于 [64]"
    },
    {
      "name": "vcltq_u64",
      "full name": "uint64x2_t vcltq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[vector] cmhi [64]",
      "function_cn": "[向量] 比较小于 [64]"
    },
    {
      "name": "vclt_f64",
      "full name": "uint64x1_t vclt_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [64]",
      "function_cn": "[向量] 比较小于 [64]"
    },
    {
      "name": "vcltq_f64",
      "full name": "uint64x2_t vcltq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "_mm_cmplt_pd",
      "Intel Asm": "cmppd",
      "Arm Asm": "fcmgt",
      "function_en": "[vector] fcmgt [64]",
      "function_cn": "[向量] 比较小于 [64]"
    },
    {
      "name": "vcltd_s64",
      "full name": "uint64_t vcltd_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmgt",
      "function_en": "[scalar] cmgt [64]",
      "function_cn": "[标量] 比较小于 [64]"
    },
    {
      "name": "vcltd_u64",
      "full name": "uint64_t vcltd_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmhi",
      "function_en": "[scalar] cmhi [64]",
      "function_cn": "[标量] 比较小于 [64]"
    },
    {
      "name": "vclts_f32",
      "full name": "uint32_t vclts_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[scalar] fcmgt [32]",
      "function_cn": "[标量] 比较小于 [32]"
    },
    {
      "name": "vcltd_f64",
      "full name": "uint64_t vcltd_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmgt",
      "function_en": "[scalar] fcmgt [64]",
      "function_cn": "[标量] 比较小于 [64]"
    },
    {
      "name": "vcltz_s8",
      "full name": "uint8x8_t vcltz_s8(int8x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [8]",
      "function_cn": "[向量] 比较是否小于零寄存器 [8]"
    },
    {
      "name": "vcltzq_s8",
      "full name": "uint8x16_t vcltzq_s8(int8x16_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [8]",
      "function_cn": "[向量] 比较是否小于零寄存器 [8]"
    },
    {
      "name": "vcltz_s16",
      "full name": "uint16x4_t vcltz_s16(int16x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [16]",
      "function_cn": "[向量] 比较是否小于零寄存器 [16]"
    },
    {
      "name": "vcltzq_s16",
      "full name": "uint16x8_t vcltzq_s16(int16x8_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [16]",
      "function_cn": "[向量] 比较是否小于零寄存器 [16]"
    },
    {
      "name": "vcltz_s32",
      "full name": "uint32x2_t vcltz_s32(int32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [32]",
      "function_cn": "[向量] 比较是否小于零寄存器 [32]"
    },
    {
      "name": "vcltzq_s32",
      "full name": "uint32x4_t vcltzq_s32(int32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [32]",
      "function_cn": "[向量] 比较是否小于零寄存器 [32]"
    },
    {
      "name": "vcltz_s64",
      "full name": "uint64x1_t vcltz_s64(int64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [64]",
      "function_cn": "[向量] 比较是否小于零寄存器 [64]"
    },
    {
      "name": "vcltzq_s64",
      "full name": "uint64x2_t vcltzq_s64(int64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[vector] cmlt [64]",
      "function_cn": "[向量] 比较是否小于零寄存器 [64]"
    },
    {
      "name": "vcltz_f32",
      "full name": "uint32x2_t vcltz_f32(float32x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmlt",
      "function_en": "[vector] fcmlt [32]",
      "function_cn": "[向量] 比较是否小于零寄存器 [32]"
    },
    {
      "name": "vcltzq_f32",
      "full name": "uint32x4_t vcltzq_f32(float32x4_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmlt",
      "function_en": "[vector] fcmlt [32]",
      "function_cn": "[向量] 比较是否小于零寄存器 [32]"
    },
    {
      "name": "vcltz_f64",
      "full name": "uint64x1_t vcltz_f64(float64x1_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmlt",
      "function_en": "[vector] fcmlt [64]",
      "function_cn": "[向量] 比较是否小于零寄存器 [64]"
    },
    {
      "name": "vcltzq_f64",
      "full name": "uint64x2_t vcltzq_f64(float64x2_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmlt",
      "function_en": "[vector] fcmlt [64]",
      "function_cn": "[向量] 比较是否小于零寄存器 [64]"
    },
    {
      "name": "vcltzd_s64",
      "full name": "uint64_t vcltzd_s64(int64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmlt",
      "function_en": "[scalar] cmlt [64]",
      "function_cn": "[标量] 比较是否小于零寄存器 [64]"
    },
    {
      "name": "vcltzs_f32",
      "full name": "uint32_t vcltzs_f32(float32_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmlt",
      "function_en": "[scalar] fcmlt [32]",
      "function_cn": "[标量] 比较是否小于零寄存器 [32]"
    },
    {
      "name": "vcltzd_f64",
      "full name": "uint64_t vcltzd_f64(float64_t a)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fcmlt",
      "function_en": "[scalar] fcmlt [64]",
      "function_cn": "[标量] 比较是否小于零寄存器 [64]"
    },
    {
      "name": "vcage_f32",
      "full name": "uint32x2_t vcage_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [32]",
      "function_cn": "[向量] 比较绝对值大于等于 [32]"
    },
    {
      "name": "vcageq_f32",
      "full name": "uint32x4_t vcageq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [32]",
      "function_cn": "[向量] 比较绝对值大于等于 [32]"
    },
    {
      "name": "vcage_f64",
      "full name": "uint64x1_t vcage_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [64]",
      "function_cn": "[向量] 比较绝对值大于等于 [64]"
    },
    {
      "name": "vcageq_f64",
      "full name": "uint64x2_t vcageq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [64]",
      "function_cn": "[向量] 比较绝对值大于等于 [64]"
    },
    {
      "name": "vcages_f32",
      "full name": "uint32_t vcages_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[scalar] facge [32]",
      "function_cn": "[标量] 比较绝对值大于等于 [32]"
    },
    {
      "name": "vcaged_f64",
      "full name": "uint64_t vcaged_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[scalar] facge [64]",
      "function_cn": "[标量] 比较绝对值大于等于 [64]"
    },
    {
      "name": "vcale_f32",
      "full name": "uint32x2_t vcale_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [32]",
      "function_cn": "[向量] 比较绝对值小于等于 [32]"
    },
    {
      "name": "vcaleq_f32",
      "full name": "uint32x4_t vcaleq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [32]",
      "function_cn": "[向量] 比较绝对值小于等于 [32]"
    },
    {
      "name": "vcale_f64",
      "full name": "uint64x1_t vcale_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [64]",
      "function_cn": "[向量] 比较绝对值小于等于 [64]"
    },
    {
      "name": "vcaleq_f64",
      "full name": "uint64x2_t vcaleq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[vector] facge [64]",
      "function_cn": "[向量] 比较绝对值小于等于 [64]"
    },
    {
      "name": "vcales_f32",
      "full name": "uint32_t vcales_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[scalar] facge [32]",
      "function_cn": "[标量] 比较绝对值小于等于 [32]"
    },
    {
      "name": "vcaled_f64",
      "full name": "uint64_t vcaled_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facge",
      "function_en": "[scalar] facge [64]",
      "function_cn": "[标量] 比较绝对值小于等于 [64]"
    },
    {
      "name": "vcagt_f32",
      "full name": "uint32x2_t vcagt_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [32]",
      "function_cn": "[向量] 比较绝对值大于 [32]"
    },
    {
      "name": "vcagtq_f32",
      "full name": "uint32x4_t vcagtq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [32]",
      "function_cn": "[向量] 比较绝对值大于 [32]"
    },
    {
      "name": "vcagt_f64",
      "full name": "uint64x1_t vcagt_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [64]",
      "function_cn": "[向量] 比较绝对值大于 [64]"
    },
    {
      "name": "vcagtq_f64",
      "full name": "uint64x2_t vcagtq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [64]",
      "function_cn": "[向量] 比较绝对值大于 [64]"
    },
    {
      "name": "vcagts_f32",
      "full name": "uint32_t vcagts_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[scalar] facgt [32]",
      "function_cn": "[标量] 比较绝对值大于 [32]"
    },
    {
      "name": "vcagtd_f64",
      "full name": "uint64_t vcagtd_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[scalar] facgt [32]",
      "function_cn": "[标量] 比较绝对值大于 [32]"
    },
    {
      "name": "vcalt_f32",
      "full name": "uint32x2_t vcalt_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [32]",
      "function_cn": "[向量] 比较绝对值小于 [32]"
    },
    {
      "name": "vcaltq_f32",
      "full name": "uint32x4_t vcaltq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [32]",
      "function_cn": "[向量] 比较绝对值小于 [32]"
    },
    {
      "name": "vcalt_f64",
      "full name": "uint64x1_t vcalt_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [64]",
      "function_cn": "[向量] 比较绝对值小于 [64]"
    },
    {
      "name": "vcaltq_f64",
      "full name": "uint64x2_t vcaltq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[vector] facgt [64]",
      "function_cn": "[向量] 比较绝对值小于 [64]"
    },
    {
      "name": "vcalts_f32",
      "full name": "uint32_t vcalts_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[scalar] facgt [32]",
      "function_cn": "[标量] 比较绝对值小于 [32]"
    },
    {
      "name": "vcaltd_f64",
      "full name": "uint64_t vcaltd_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "facgt",
      "function_en": "[scalar] facgt [64]",
      "function_cn": "[标量] 比较绝对值小于 [64]"
    },
    {
      "name": "vtst_s8",
      "full name": "uint8x8_t vtst_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [8]",
      "function_cn": "[向量] 按位比较测试位非零 [8]"
    },
    {
      "name": "vtstq_s8",
      "full name": "uint8x16_t vtstq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [8]",
      "function_cn": "[向量] 按位比较测试位非零 [8]"
    },
    {
      "name": "vtst_s16",
      "full name": "uint16x4_t vtst_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [16]",
      "function_cn": "[向量] 按位比较测试位非零 [16]"
    },
    {
      "name": "vtstq_s16",
      "full name": "uint16x8_t vtstq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [16]",
      "function_cn": "[向量] 按位比较测试位非零 [16]"
    },
    {
      "name": "vtst_s32",
      "full name": "uint32x2_t vtst_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [32]",
      "function_cn": "[向量] 按位比较测试位非零 [32]"
    },
    {
      "name": "vtstq_s32",
      "full name": "uint32x4_t vtstq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [32]",
      "function_cn": "[向量] 按位比较测试位非零 [32]"
    },
    {
      "name": "vtst_u8",
      "full name": "uint8x8_t vtst_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [8]",
      "function_cn": "[向量] 按位比较测试位非零 [8]"
    },
    {
      "name": "vtstq_u8",
      "full name": "uint8x16_t vtstq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [8]",
      "function_cn": "[向量] 按位比较测试位非零 [8]"
    },
    {
      "name": "vtst_u16",
      "full name": "uint16x4_t vtst_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [16]",
      "function_cn": "[向量] 按位比较测试位非零 [16]"
    },
    {
      "name": "vtstq_u16",
      "full name": "uint16x8_t vtstq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [16]",
      "function_cn": "[向量] 按位比较测试位非零 [16]"
    },
    {
      "name": "vtst_u32",
      "full name": "uint32x2_t vtst_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [32]",
      "function_cn": "[向量] 按位比较测试位非零 [32]"
    },
    {
      "name": "vtstq_u32",
      "full name": "uint32x4_t vtstq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [32]",
      "function_cn": "[向量] 按位比较测试位非零 [32]"
    },
    {
      "name": "vtst_p8",
      "full name": "uint8x8_t vtst_p8(poly8x8_t a, poly8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [8]",
      "function_cn": "[向量] 按位比较测试位非零 [8]"
    },
    {
      "name": "vtstq_p8",
      "full name": "uint8x16_t vtstq_p8(poly8x16_t a, poly8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [8]",
      "function_cn": "[向量] 按位比较测试位非零 [8]"
    },
    {
      "name": "vtst_p16",
      "full name": "uint16x4_t vtst_p16(poly16x4_t a, poly16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [16]",
      "function_cn": "[向量] 按位比较测试位非零 [16]"
    },
    {
      "name": "vtstq_p16",
      "full name": "uint16x8_t vtstq_p16(poly16x8_t a, poly16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [16]",
      "function_cn": "[向量] 按位比较测试位非零 [16]"
    },
    {
      "name": "vtst_s64",
      "full name": "uint64x1_t vtst_s64(int64x1_t a, int64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [64]",
      "function_cn": "[向量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtstq_s64",
      "full name": "uint64x2_t vtstq_s64(int64x2_t a, int64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [64]",
      "function_cn": "[向量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtst_u64",
      "full name": "uint64x1_t vtst_u64(uint64x1_t a, uint64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [64]",
      "function_cn": "[向量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtstq_u64",
      "full name": "uint64x2_t vtstq_u64(uint64x2_t a, uint64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [64]",
      "function_cn": "[向量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtst_p64",
      "full name": "uint64x1_t vtst_p64(poly64x1_t a, poly64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [64]",
      "function_cn": "[向量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtstq_p64",
      "full name": "uint64x2_t vtstq_p64(poly64x2_t a, poly64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[vector] cmtst [64]",
      "function_cn": "[向量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtstd_s64",
      "full name": "uint64_t vtstd_s64(int64_t a, int64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[scalar] cmtst [64]",
      "function_cn": "[标量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vtstd_u64",
      "full name": "uint64_t vtstd_u64(uint64_t a, uint64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "cmtst",
      "function_en": "[scalar] cmtst [64]",
      "function_cn": "[标量] 按位比较测试位非零 [64]"
    },
    {
      "name": "vabd_s8",
      "full name": "int8x8_t vabd_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabd",
      "function_en": "[vector] sabd [8]",
      "function_cn": "[向量] 绝对差值 [8]"
    },
    {
      "name": "vabdq_s8",
      "full name": "int8x16_t vabdq_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabd",
      "function_en": "[vector] sabd [8]",
      "function_cn": "[向量] 绝对差值 [8]"
    },
    {
      "name": "vabd_s16",
      "full name": "int16x4_t vabd_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabd",
      "function_en": "[vector] sabd [16]",
      "function_cn": "[向量] 绝对差值 [16]"
    },
    {
      "name": "vabdq_s16",
      "full name": "int16x8_t vabdq_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabd",
      "function_en": "[vector] sabd [16]",
      "function_cn": "[向量] 绝对差值 [16]"
    },
    {
      "name": "vabd_s32",
      "full name": "int32x2_t vabd_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabd",
      "function_en": "[vector] sabd [32]",
      "function_cn": "[向量] 绝对差值 [32]"
    },
    {
      "name": "vabdq_s32",
      "full name": "int32x4_t vabdq_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabd",
      "function_en": "[vector] sabd [32]",
      "function_cn": "[向量] 绝对差值 [32]"
    },
    {
      "name": "vabd_u8",
      "full name": "uint8x8_t vabd_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabd",
      "function_en": "[vector] uabd [8]",
      "function_cn": "[向量] 绝对差值 [8]"
    },
    {
      "name": "vabdq_u8",
      "full name": "uint8x16_t vabdq_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabd",
      "function_en": "[vector] uabd [8]",
      "function_cn": "[向量] 绝对差值 [8]"
    },
    {
      "name": "vabd_u16",
      "full name": "uint16x4_t vabd_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabd",
      "function_en": "[vector] uabd [16]",
      "function_cn": "[向量] 绝对差值 [16]"
    },
    {
      "name": "vabdq_u16",
      "full name": "uint16x8_t vabdq_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabd",
      "function_en": "[vector] uabd [16]",
      "function_cn": "[向量] 绝对差值 [16]"
    },
    {
      "name": "vabd_u32",
      "full name": "uint32x2_t vabd_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabd",
      "function_en": "[vector] uabd [32]",
      "function_cn": "[向量] 绝对差值 [32]"
    },
    {
      "name": "vabdq_u32",
      "full name": "uint32x4_t vabdq_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabd",
      "function_en": "[vector] uabd [32]",
      "function_cn": "[向量] 绝对差值 [32]"
    },
    {
      "name": "vabd_f32",
      "full name": "float32x2_t vabd_f32(float32x2_t a, float32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fabd",
      "function_en": "[vector] fabd [32]",
      "function_cn": "[向量] 绝对差值 [32]"
    },
    {
      "name": "vabdq_f32",
      "full name": "float32x4_t vabdq_f32(float32x4_t a, float32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fabd",
      "function_en": "[vector] fabd [32]",
      "function_cn": "[向量] 绝对差值 [32]"
    },
    {
      "name": "vabd_f64",
      "full name": "float64x1_t vabd_f64(float64x1_t a, float64x1_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fabd",
      "function_en": "[vector] fabd [64]",
      "function_cn": "[向量] 绝对差值 [64]"
    },
    {
      "name": "vabdq_f64",
      "full name": "float64x2_t vabdq_f64(float64x2_t a, float64x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fabd",
      "function_en": "[vector] fabd [64]",
      "function_cn": "[向量] 绝对差值 [64]"
    },
    {
      "name": "vabds_f32",
      "full name": "float32_t vabds_f32(float32_t a, float32_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fabd",
      "function_en": "[scalar] fabd [32]",
      "function_cn": "[标量] 绝对差值 [32]"
    },
    {
      "name": "vabdd_f64",
      "full name": "float64_t vabdd_f64(float64_t a, float64_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "fabd",
      "function_en": "[scalar] fabd [64]",
      "function_cn": "[标量] 绝对差值 [64]"
    },
    {
      "name": "vabdl_s8",
      "full name": "int16x8_t vabdl_s8(int8x8_t a, int8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabdl",
      "function_en": "[vector] sabdl [8]",
      "function_cn": "[向量] 长型绝对差值 [8]"
    },
    {
      "name": "vabdl_s16",
      "full name": "int32x4_t vabdl_s16(int16x4_t a, int16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabdl",
      "function_en": "[vector] sabdl [16]",
      "function_cn": "[向量] 长型绝对差值 [16]"
    },
    {
      "name": "vabdl_s32",
      "full name": "int64x2_t vabdl_s32(int32x2_t a, int32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabdl",
      "function_en": "[vector] sabdl [32]",
      "function_cn": "[向量] 长型绝对差值 [32]"
    },
    {
      "name": "vabdl_u8",
      "full name": "uint16x8_t vabdl_u8(uint8x8_t a, uint8x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabdl",
      "function_en": "[vector] uabdl [8]",
      "function_cn": "[向量] 长型绝对差值 [8]"
    },
    {
      "name": "vabdl_u16",
      "full name": "uint32x4_t vabdl_u16(uint16x4_t a, uint16x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabdl",
      "function_en": "[vector] uabdl [16]",
      "function_cn": "[向量] 长型绝对差值 [16]"
    },
    {
      "name": "vabdl_u32",
      "full name": "uint64x2_t vabdl_u32(uint32x2_t a, uint32x2_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabdl",
      "function_en": "[vector] uabdl [32]",
      "function_cn": "[向量] 长型绝对差值 [32]"
    },
    {
      "name": "vabdl_high_s8",
      "full name": "int16x8_t vabdl_high_s8(int8x16_t a, int8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabdl2",
      "function_en": "[vector] sabdl2 [8]",
      "function_cn": "[向量] 长型绝对差值 [8]"
    },
    {
      "name": "vabdl_high_s16",
      "full name": "int32x4_t vabdl_high_s16(int16x8_t a, int16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabdl2",
      "function_en": "[vector] sabdl2 [16]",
      "function_cn": "[向量] 长型绝对差值 [16]"
    },
    {
      "name": "vabdl_high_s32",
      "full name": "int64x2_t vabdl_high_s32(int32x4_t a, int32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabdl2",
      "function_en": "[vector] sabdl2 [32]",
      "function_cn": "[向量] 长型绝对差值 [32]"
    },
    {
      "name": "vabdl_high_u8",
      "full name": "uint16x8_t vabdl_high_u8(uint8x16_t a, uint8x16_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabdl2",
      "function_en": "[vector] uabdl2 [8]",
      "function_cn": "[向量] 长型绝对差值 [8]"
    },
    {
      "name": "vabdl_high_u16",
      "full name": "uint32x4_t vabdl_high_u16(uint16x8_t a, uint16x8_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabdl2",
      "function_en": "[vector] uabdl2 [16]",
      "function_cn": "[向量] 长型绝对差值 [16]"
    },
    {
      "name": "vabdl_high_u32",
      "full name": "uint64x2_t vabdl_high_u32(uint32x4_t a, uint32x4_t b)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabdl2",
      "function_en": "[vector] uabdl2 [32]",
      "function_cn": "[向量] 长型绝对差值 [32]"
    },
    {
      "name": "vaba_s8",
      "full name": "int8x8_t vaba_s8(int8x8_t a, int8x8_t b, int8x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saba",
      "function_en": "[vector] saba [8]",
      "function_cn": "[向量] 绝对差值再相加 [8]"
    },
    {
      "name": "vabaq_s8",
      "full name": "int8x16_t vabaq_s8(int8x16_t a, int8x16_t b, int8x16_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saba",
      "function_en": "[vector] saba [8]",
      "function_cn": "[向量] 绝对差值再相加 [8]"
    },
    {
      "name": "vaba_s16",
      "full name": "int16x4_t vaba_s16(int16x4_t a, int16x4_t b, int16x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saba",
      "function_en": "[vector] saba [16]",
      "function_cn": "[向量] 绝对差值再相加 [16]"
    },
    {
      "name": "vabaq_s16",
      "full name": "int16x8_t vabaq_s16(int16x8_t a, int16x8_t b, int16x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saba",
      "function_en": "[vector] saba [16]",
      "function_cn": "[向量] 绝对差值再相加 [16]"
    },
    {
      "name": "vaba_s32",
      "full name": "int32x2_t vaba_s32(int32x2_t a, int32x2_t b, int32x2_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saba",
      "function_en": "[vector] saba [32]",
      "function_cn": "[向量] 绝对差值再相加 [32]"
    },
    {
      "name": "vabaq_s32",
      "full name": "int32x4_t vabaq_s32(int32x4_t a, int32x4_t b, int32x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "saba",
      "function_en": "[vector] saba [32]",
      "function_cn": "[向量] 绝对差值再相加 [32]"
    },
    {
      "name": "vaba_u8",
      "full name": "uint8x8_t vaba_u8(uint8x8_t a, uint8x8_t b, uint8x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaba",
      "function_en": "[vector] uaba [8]",
      "function_cn": "[向量] 绝对差值再相加 [8]"
    },
    {
      "name": "vabaq_u8",
      "full name": "uint8x16_t vabaq_u8(uint8x16_t a, uint8x16_t b, uint8x16_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaba",
      "function_en": "[vector] uaba [8]",
      "function_cn": "[向量] 绝对差值再相加 [8]"
    },
    {
      "name": "vaba_u16",
      "full name": "uint16x4_t vaba_u16(uint16x4_t a, uint16x4_t b, uint16x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaba",
      "function_en": "[vector] uaba [16]",
      "function_cn": "[向量] 绝对差值再相加 [16]"
    },
    {
      "name": "vabaq_u16",
      "full name": "uint16x8_t vabaq_u16(uint16x8_t a, uint16x8_t b, uint16x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaba",
      "function_en": "[vector] uaba [16]",
      "function_cn": "[向量] 绝对差值再相加 [16]"
    },
    {
      "name": "vaba_u32",
      "full name": "uint32x2_t vaba_u32(uint32x2_t a, uint32x2_t b, uint32x2_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaba",
      "function_en": "[vector] uaba [32]",
      "function_cn": "[向量] 绝对差值再相加 [32]"
    },
    {
      "name": "vabaq_u32",
      "full name": "uint32x4_t vabaq_u32(uint32x4_t a, uint32x4_t b, uint32x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uaba",
      "function_en": "[vector] uaba [32]",
      "function_cn": "[向量] 绝对差值再相加 [32]"
    },
    {
      "name": "vabal_s8",
      "full name": "int16x8_t vabal_s8(int16x8_t a, int8x8_t b, int8x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabal",
      "function_en": "[vector] sabal [8]",
      "function_cn": "[向量] 长型绝对差值再相加 [8]"
    },
    {
      "name": "vabal_s16",
      "full name": "int32x4_t vabal_s16(int32x4_t a, int16x4_t b, int16x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabal",
      "function_en": "[vector] sabal [16]",
      "function_cn": "[向量] 长型绝对差值再相加 [16]"
    },
    {
      "name": "vabal_s32",
      "full name": "int64x2_t vabal_s32(int64x2_t a, int32x2_t b, int32x2_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabal",
      "function_en": "[vector] sabal [32]",
      "function_cn": "[向量] 长型绝对差值再相加 [32]"
    },
    {
      "name": "vabal_u8",
      "full name": "uint16x8_t vabal_u8(uint16x8_t a, uint8x8_t b, uint8x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabal",
      "function_en": "[vector] uabal [8]",
      "function_cn": "[向量] 长型绝对差值再相加 [8]"
    },
    {
      "name": "vabal_u16",
      "full name": "uint32x4_t vabal_u16(uint32x4_t a, uint16x4_t b, uint16x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabal",
      "function_en": "[vector] uabal [16]",
      "function_cn": "[向量] 长型绝对差值再相加 [16]"
    },
    {
      "name": "vabal_u32",
      "full name": "uint64x2_t vabal_u32(uint64x2_t a, uint32x2_t b, uint32x2_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabal",
      "function_en": "[vector] uabal [32]",
      "function_cn": "[向量] 长型绝对差值再相加 [32]"
    },
    {
      "name": "vabal_high_s8",
      "full name": "int16x8_t vabal_high_s8(int16x8_t a, int8x16_t b, int8x16_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabal2",
      "function_en": "[vector] sabal2 [8]",
      "function_cn": "[向量] 长型绝对差值再相加 [8]"
    },
    {
      "name": "vabal_high_s16",
      "full name": "int32x4_t vabal_high_s16(int32x4_t a, int16x8_t b, int16x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabal2",
      "function_en": "[vector] sabal2 [16]",
      "function_cn": "[向量] 长型绝对差值再相加 [16]"
    },
    {
      "name": "vabal_high_s32",
      "full name": "int64x2_t vabal_high_s32(int64x2_t a, int32x4_t b, int32x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "sabal2",
      "function_en": "[vector] sabal2 [32]",
      "function_cn": "[向量] 长型绝对差值再相加 [32]"
    },
    {
      "name": "vabal_high_u8",
      "full name": "uint16x8_t vabal_high_u8(uint16x8_t a, uint8x16_t b, uint8x16_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabal2",
      "function_en": "[vector] uabal2 [8]",
      "function_cn": "[向量] 长型绝对差值再相加 [8]"
    },
    {
      "name": "vabal_high_u16",
      "full name": "uint32x4_t vabal_high_u16(uint32x4_t a, uint16x8_t b, uint16x8_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabal2",
      "function_en": "[vector] uabal2 [16]",
      "function_cn": "[向量] 长型绝对差值再相加 [16]"
    },
    {
      "name": "vabal_high_u32",
      "full name": "uint64x2_t vabal_high_u32(uint64x2_t a, uint32x4_t b, uint32x4_t c)",
      "Intel name": "",
      "Intel Asm": "",
      "Arm Asm": "uabal2",
      "function_en": "[vector] uabal2 [32]",
      "function_cn": "[向量] 长型绝对差值再相加 [32]"
    }
  ]
}

